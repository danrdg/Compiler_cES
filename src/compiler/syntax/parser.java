
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Thu Apr 06 09:40:15 CEST 2023
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Thu Apr 06 09:40:15 CEST 2023
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\144\000\002\002\004\000\002\055\002\000\002\002" +
    "\004\000\002\056\002\000\002\003\004\000\002\004\006" +
    "\000\002\004\005\000\002\015\004\000\002\015\003\000" +
    "\002\006\002\000\002\016\006\000\002\017\004\000\002" +
    "\017\003\000\002\020\011\000\002\021\003\000\002\021" +
    "\003\000\002\022\004\000\002\022\003\000\002\023\005" +
    "\000\002\023\005\000\002\024\005\000\002\024\003\000" +
    "\002\025\003\000\002\025\005\000\002\007\004\000\002" +
    "\007\003\000\002\057\002\000\002\060\002\000\002\010" +
    "\014\000\002\061\002\000\002\062\002\000\002\010\014" +
    "\000\002\012\003\000\002\012\003\000\002\013\005\000" +
    "\002\013\003\000\002\014\004\000\002\014\004\000\002" +
    "\063\002\000\002\064\002\000\002\005\013\000\002\011" +
    "\004\000\002\011\005\000\002\026\003\000\002\026\003" +
    "\000\002\026\005\000\002\026\005\000\002\026\005\000" +
    "\002\026\004\000\002\026\004\000\002\026\005\000\002" +
    "\026\005\000\002\026\005\000\002\026\003\000\002\026" +
    "\003\000\002\027\006\000\002\030\006\000\002\030\005" +
    "\000\002\050\003\000\002\050\005\000\002\065\002\000" +
    "\002\031\006\000\002\032\004\000\002\032\003\000\002" +
    "\033\004\000\002\033\003\000\002\034\003\000\002\034" +
    "\003\000\002\034\003\000\002\034\003\000\002\034\003" +
    "\000\002\034\003\000\002\034\003\000\002\034\003\000" +
    "\002\034\003\000\002\034\003\000\002\054\004\000\002" +
    "\054\005\000\002\035\005\000\002\036\006\000\002\037" +
    "\003\000\002\037\003\000\002\040\006\000\002\041\011" +
    "\000\002\041\007\000\002\042\012\000\002\043\004\000" +
    "\002\043\003\000\002\044\010\000\002\066\002\000\002" +
    "\045\010\000\002\045\003\000\002\046\007\000\002\047" +
    "\004\000\002\051\007\000\002\051\007\000\002\052\003" +
    "\000\002\052\003\000\002\053\003\000\002\053\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\317\000\014\027\000\031\000\043\000\044\000\045" +
    "\000\001\002\000\004\002\321\001\002\000\014\027\ufffe" +
    "\031\ufffe\043\ufffe\044\ufffe\045\ufffe\001\002\000\014\027" +
    "\010\031\ufff8\043\ufff8\044\ufff8\045\ufff8\001\002\000\004" +
    "\002\uffff\001\002\000\004\045\316\001\002\000\004\002" +
    "\ufffd\001\002\000\014\027\010\031\ufff8\043\ufff8\044\ufff8" +
    "\045\ufff8\001\002\000\012\031\ufff8\043\017\044\ufff8\045" +
    "\ufff8\001\002\000\012\031\ufff9\043\ufff9\044\ufff9\045\ufff9" +
    "\001\002\000\010\031\041\044\040\045\033\001\002\000" +
    "\030\012\ufff8\031\ufff8\032\ufff8\033\ufff8\034\ufff8\035\ufff8" +
    "\040\ufff8\041\ufff8\043\017\044\ufff8\045\ufff8\001\002\000" +
    "\004\031\021\001\002\000\026\012\ufff5\031\ufff5\032\ufff5" +
    "\033\ufff5\034\ufff5\035\ufff5\040\ufff5\041\ufff5\044\ufff5\045" +
    "\ufff5\001\002\000\004\045\022\001\002\000\004\010\023" +
    "\001\002\000\006\045\025\046\024\001\002\000\004\011" +
    "\ufff3\001\002\000\004\011\ufff2\001\002\000\004\011\027" +
    "\001\002\000\004\016\030\001\002\000\030\012\ufff4\031" +
    "\ufff4\032\ufff4\033\ufff4\034\ufff4\035\ufff4\040\ufff4\041\ufff4" +
    "\043\ufff4\044\ufff4\045\ufff4\001\002\000\026\012\ufff6\031" +
    "\ufff6\032\ufff6\033\ufff6\034\ufff6\035\ufff6\040\ufff6\041\ufff6" +
    "\044\ufff6\045\ufff6\001\002\000\026\012\ufff0\031\ufff0\032" +
    "\ufff0\033\ufff0\034\ufff0\035\ufff0\040\ufff0\041\ufff0\044\ufff0" +
    "\045\ufff0\001\002\000\004\045\167\001\002\000\004\002" +
    "\uffe8\001\002\000\006\031\313\044\040\001\002\000\004" +
    "\002\ufffb\001\002\000\010\031\041\044\040\045\033\001" +
    "\002\000\006\037\271\045\270\001\002\000\004\045\043" +
    "\001\002\000\006\016\267\017\172\001\002\000\012\014" +
    "\045\016\uffeb\017\uffeb\024\046\001\002\000\006\016\uffec" +
    "\017\uffec\001\002\000\010\015\ufff8\031\054\045\050\001" +
    "\002\000\004\046\047\001\002\000\006\016\uffea\017\uffea" +
    "\001\002\000\004\045\266\001\002\000\006\015\uffde\017" +
    "\uffde\001\002\000\004\015\061\001\002\000\004\015\uffe0" +
    "\001\002\000\004\045\060\001\002\000\006\015\uffe1\017" +
    "\056\001\002\000\006\031\054\045\050\001\002\000\006" +
    "\015\uffdf\017\uffdf\001\002\000\006\015\uffdd\017\uffdd\001" +
    "\002\000\004\012\062\001\002\000\026\012\uffe7\031\uffe7" +
    "\032\uffe7\033\uffe7\034\uffe7\035\uffe7\040\uffe7\041\uffe7\043" +
    "\uffe7\045\uffe7\001\002\000\026\012\ufff8\031\ufff8\032\ufff8" +
    "\033\ufff8\034\ufff8\035\ufff8\040\ufff8\041\ufff8\043\017\045" +
    "\ufff8\001\002\000\024\012\071\031\114\032\105\033\106" +
    "\034\076\035\115\040\072\041\110\045\112\001\002\000" +
    "\004\013\uffe6\001\002\000\004\013\067\001\002\000\006" +
    "\031\uffe5\044\uffe5\001\002\000\026\012\uffba\013\uffba\032" +
    "\uffba\033\uffba\034\uffba\035\uffba\040\uffba\041\uffba\042\uffba" +
    "\045\uffba\001\002\000\024\012\uffc5\031\uffc5\032\uffc5\033" +
    "\uffc5\034\uffc5\035\uffc5\040\uffc5\041\uffc5\045\uffc5\001\002" +
    "\000\014\014\127\016\255\021\136\045\137\046\132\001" +
    "\002\000\026\012\uffbb\013\uffbb\032\uffbb\033\uffbb\034\uffbb" +
    "\035\uffbb\040\uffbb\041\uffbb\042\uffbb\045\uffbb\001\002\000" +
    "\024\012\071\031\114\032\105\033\106\034\076\035\115" +
    "\040\072\041\110\045\112\001\002\000\006\023\uffb0\024" +
    "\uffb0\001\002\000\004\014\225\001\002\000\026\012\uffbd" +
    "\013\uffbd\032\uffbd\033\uffbd\034\uffbd\035\uffbd\040\uffbd\041" +
    "\uffbd\042\uffbd\045\uffbd\001\002\000\004\016\224\001\002" +
    "\000\006\023\216\024\217\001\002\000\026\012\uffb6\013" +
    "\uffb6\032\uffb6\033\uffb6\034\uffb6\035\uffb6\040\uffb6\041\uffb6" +
    "\042\uffb6\045\uffb6\001\002\000\026\012\uffbe\013\uffbe\032" +
    "\uffbe\033\uffbe\034\uffbe\035\uffbe\040\uffbe\041\uffbe\042\uffbe" +
    "\045\uffbe\001\002\000\024\012\uffc0\013\uffc0\032\uffc0\033" +
    "\uffc0\034\uffc0\035\uffc0\040\uffc0\041\uffc0\045\uffc0\001\002" +
    "\000\004\014\210\001\002\000\004\014\202\001\002\000" +
    "\026\012\uffb7\013\uffb7\032\uffb7\033\uffb7\034\uffb7\035\uffb7" +
    "\040\uffb7\041\uffb7\042\uffb7\045\uffb7\001\002\000\004\014" +
    "\174\001\002\000\026\012\uffb8\013\uffb8\032\uffb8\033\uffb8" +
    "\034\uffb8\035\uffb8\040\uffb8\041\uffb8\042\uffb8\045\uffb8\001" +
    "\002\000\016\005\125\010\123\014\124\023\uffb1\024\uffb1" +
    "\045\167\001\002\000\026\012\uffb9\013\uffb9\032\uffb9\033" +
    "\uffb9\034\uffb9\035\uffb9\040\uffb9\041\uffb9\042\uffb9\045\uffb9" +
    "\001\002\000\004\045\167\001\002\000\004\014\163\001" +
    "\002\000\026\012\uffbc\013\uffbc\032\uffbc\033\uffbc\034\uffbc" +
    "\035\uffbc\040\uffbc\041\uffbc\042\uffbc\045\uffbc\001\002\000" +
    "\026\012\uffbf\013\uffbf\032\uffbf\033\uffbf\034\uffbf\035\uffbf" +
    "\040\uffbf\041\uffbf\042\uffbf\045\uffbf\001\002\000\024\012" +
    "\071\013\uffd8\032\105\033\106\034\076\035\115\040\072" +
    "\041\110\045\122\001\002\000\024\012\uffc1\013\uffc1\032" +
    "\uffc1\033\uffc1\034\uffc1\035\uffc1\040\uffc1\041\uffc1\045\uffc1" +
    "\001\002\000\014\005\125\010\123\014\124\023\uffb1\024" +
    "\uffb1\001\002\000\012\014\127\021\136\045\137\046\132" +
    "\001\002\000\014\014\127\015\131\021\136\045\137\046" +
    "\132\001\002\000\004\016\126\001\002\000\026\012\uffb3" +
    "\013\uffb3\032\uffb3\033\uffb3\034\uffb3\035\uffb3\040\uffb3\041" +
    "\uffb3\042\uffb3\045\uffb3\001\002\000\012\014\127\021\136" +
    "\045\137\046\132\001\002\000\026\004\uffcc\005\uffcc\006" +
    "\uffcc\007\uffcc\011\uffcc\015\uffcc\016\uffcc\017\uffcc\022\uffcc" +
    "\025\uffcc\001\002\000\026\004\uffc8\005\uffc8\006\uffc8\007" +
    "\uffc8\011\uffc8\015\uffc8\016\uffc8\017\uffc8\022\uffc8\025\uffc8" +
    "\001\002\000\026\004\uffd6\005\uffd6\006\uffd6\007\uffd6\011" +
    "\uffd6\015\uffd6\016\uffd6\017\uffd6\022\uffd6\025\uffd6\001\002" +
    "\000\022\004\142\005\146\006\141\007\145\015\uffc7\017" +
    "\uffc7\022\144\025\143\001\002\000\026\004\uffcb\005\uffcb" +
    "\006\uffcb\007\uffcb\011\uffcb\015\uffcb\016\uffcb\017\uffcb\022" +
    "\uffcb\025\uffcb\001\002\000\006\015\154\017\155\001\002" +
    "\000\012\014\127\021\136\045\137\046\132\001\002\000" +
    "\032\004\uffd5\005\uffd5\006\uffd5\007\uffd5\010\123\011\uffd5" +
    "\014\124\015\uffd5\016\uffd5\017\uffd5\022\uffd5\025\uffd5\001" +
    "\002\000\026\004\uffd0\005\uffd0\006\uffd0\007\uffd0\011\uffd0" +
    "\015\uffd0\016\uffd0\017\uffd0\022\uffd0\025\uffd0\001\002\000" +
    "\012\014\127\021\136\045\137\046\132\001\002\000\012" +
    "\014\127\021\136\045\137\046\132\001\002\000\012\014" +
    "\127\021\136\045\137\046\132\001\002\000\012\014\127" +
    "\021\136\045\137\046\132\001\002\000\012\014\127\021" +
    "\136\045\137\046\132\001\002\000\026\004\uffd1\005\uffd1" +
    "\006\uffd1\007\uffd1\011\uffd1\015\uffd1\016\uffd1\017\uffd1\022" +
    "\uffd1\025\uffd1\001\002\000\026\004\142\005\146\006\141" +
    "\007\uffcd\011\uffcd\015\uffcd\016\uffcd\017\uffcd\022\144\025" +
    "\143\001\002\000\026\004\142\005\146\006\141\007\uffce" +
    "\011\uffce\015\uffce\016\uffce\017\uffce\022\uffce\025\143\001" +
    "\002\000\026\004\142\005\146\006\141\007\uffcf\011\uffcf" +
    "\015\uffcf\016\uffcf\017\uffcf\022\uffcf\025\uffcf\001\002\000" +
    "\026\004\uffd3\005\146\006\141\007\uffd3\011\uffd3\015\uffd3" +
    "\016\uffd3\017\uffd3\022\uffd3\025\uffd3\001\002\000\026\004" +
    "\uffd2\005\146\006\uffd2\007\uffd2\011\uffd2\015\uffd2\016\uffd2" +
    "\017\uffd2\022\uffd2\025\uffd2\001\002\000\026\004\uffc9\005" +
    "\uffc9\006\uffc9\007\uffc9\011\uffc9\015\uffc9\016\uffc9\017\uffc9" +
    "\022\uffc9\025\uffc9\001\002\000\012\014\127\021\136\045" +
    "\137\046\132\001\002\000\022\004\142\005\146\006\141" +
    "\007\145\015\uffc6\017\uffc6\022\144\025\143\001\002\000" +
    "\020\004\142\005\146\006\141\007\145\015\160\022\144" +
    "\025\143\001\002\000\026\004\uffd4\005\uffd4\006\uffd4\007" +
    "\uffd4\011\uffd4\015\uffd4\016\uffd4\017\uffd4\022\uffd4\025\uffd4" +
    "\001\002\000\020\004\142\005\146\006\141\007\145\011" +
    "\162\022\144\025\143\001\002\000\032\004\uffca\005\uffca" +
    "\006\uffca\007\uffca\011\uffca\015\uffca\016\uffca\017\uffca\022" +
    "\uffca\023\uffca\024\uffca\025\uffca\001\002\000\012\014\127" +
    "\021\136\045\137\046\132\001\002\000\020\004\142\005" +
    "\146\006\141\007\145\015\165\022\144\025\143\001\002" +
    "\000\022\012\071\032\105\033\106\034\076\035\115\040" +
    "\072\041\110\045\122\001\002\000\026\012\uffa5\013\uffa5" +
    "\032\uffa5\033\uffa5\034\uffa5\035\uffa5\040\uffa5\041\uffa5\042" +
    "\uffa5\045\uffa5\001\002\000\010\016\uffeb\017\uffeb\024\046" +
    "\001\002\000\006\016\171\017\172\001\002\000\026\012" +
    "\uffee\031\uffee\032\uffee\033\uffee\034\uffee\035\uffee\040\uffee" +
    "\041\uffee\044\uffee\045\uffee\001\002\000\004\045\167\001" +
    "\002\000\006\016\uffed\017\uffed\001\002\000\012\014\127" +
    "\021\136\045\137\046\132\001\002\000\020\004\142\005" +
    "\146\006\141\007\145\015\176\022\144\025\143\001\002" +
    "\000\022\012\071\032\105\033\106\034\076\035\115\040" +
    "\072\041\110\045\122\001\002\000\026\012\uffad\013\uffad" +
    "\032\uffad\033\uffad\034\uffad\035\uffad\040\uffad\041\uffad\042" +
    "\200\045\uffad\001\002\000\022\012\071\032\105\033\106" +
    "\034\076\035\115\040\072\041\110\045\122\001\002\000" +
    "\026\012\uffae\013\uffae\032\uffae\033\uffae\034\uffae\035\uffae" +
    "\040\uffae\041\uffae\042\uffae\045\uffae\001\002\000\014\014" +
    "\127\015\ufff8\021\136\045\137\046\132\001\002\000\004" +
    "\015\206\001\002\000\020\004\142\005\146\006\141\007" +
    "\145\015\uff9e\022\144\025\143\001\002\000\004\015\uff9f" +
    "\001\002\000\004\016\207\001\002\000\026\012\uffa2\013" +
    "\uffa2\032\uffa2\033\uffa2\034\uffa2\035\uffa2\040\uffa2\041\uffa2" +
    "\042\uffa2\045\uffa2\001\002\000\006\015\ufff8\047\212\001" +
    "\002\000\004\015\214\001\002\000\004\015\uffa0\001\002" +
    "\000\004\015\uffa1\001\002\000\004\016\215\001\002\000" +
    "\026\012\uffa3\013\uffa3\032\uffa3\033\uffa3\034\uffa3\035\uffa3" +
    "\040\uffa3\041\uffa3\042\uffa3\045\uffa3\001\002\000\012\014" +
    "\127\021\136\045\137\046\132\001\002\000\012\014\127" +
    "\021\136\045\137\046\132\001\002\000\020\004\142\005" +
    "\146\006\141\007\145\016\221\022\144\025\143\001\002" +
    "\000\026\012\uffb2\013\uffb2\032\uffb2\033\uffb2\034\uffb2\035" +
    "\uffb2\040\uffb2\041\uffb2\042\uffb2\045\uffb2\001\002\000\020" +
    "\004\142\005\146\006\141\007\145\016\223\022\144\025" +
    "\143\001\002\000\026\012\uffaf\013\uffaf\032\uffaf\033\uffaf" +
    "\034\uffaf\035\uffaf\040\uffaf\041\uffaf\042\uffaf\045\uffaf\001" +
    "\002\000\026\012\uffa4\013\uffa4\032\uffa4\033\uffa4\034\uffa4" +
    "\035\uffa4\040\uffa4\041\uffa4\042\uffa4\045\uffa4\001\002\000" +
    "\012\014\127\021\136\045\137\046\132\001\002\000\020" +
    "\004\142\005\146\006\141\007\145\015\227\022\144\025" +
    "\143\001\002\000\004\012\230\001\002\000\004\026\233" +
    "\001\002\000\010\013\ufff8\026\233\036\242\001\002\000" +
    "\010\013\uffaa\026\uffaa\036\uffaa\001\002\000\004\046\234" +
    "\001\002\000\004\020\235\001\002\000\004\012\071\001" +
    "\002\000\004\030\237\001\002\000\004\016\240\001\002" +
    "\000\010\013\uffa9\026\uffa9\036\uffa9\001\002\000\004\013" +
    "\252\001\002\000\004\020\245\001\002\000\010\013\uffab" +
    "\026\uffab\036\uffab\001\002\000\004\013\uffa6\001\002\000" +
    "\004\012\071\001\002\000\004\030\uffa8\001\002\000\004" +
    "\030\250\001\002\000\004\016\251\001\002\000\004\013" +
    "\uffa7\001\002\000\026\012\uffac\013\uffac\032\uffac\033\uffac" +
    "\034\uffac\035\uffac\040\uffac\041\uffac\042\uffac\045\uffac\001" +
    "\002\000\026\012\ufff1\031\ufff1\032\ufff1\033\ufff1\034\ufff1" +
    "\035\ufff1\040\ufff1\041\ufff1\044\ufff1\045\ufff1\001\002\000" +
    "\024\012\071\013\uffd7\032\105\033\106\034\076\035\115" +
    "\040\072\041\110\045\122\001\002\000\026\012\uffb5\013" +
    "\uffb5\032\uffb5\033\uffb5\034\uffb5\035\uffb5\040\uffb5\041\uffb5" +
    "\042\uffb5\045\uffb5\001\002\000\020\004\142\005\146\006" +
    "\141\007\145\016\257\022\144\025\143\001\002\000\026" +
    "\012\uffb4\013\uffb4\032\uffb4\033\uffb4\034\uffb4\035\uffb4\040" +
    "\uffb4\041\uffb4\042\uffb4\045\uffb4\001\002\000\024\012\071" +
    "\031\114\032\105\033\106\034\076\035\115\040\072\041" +
    "\110\045\112\001\002\000\004\013\265\001\002\000\024" +
    "\012\071\031\114\032\105\033\106\034\076\035\115\040" +
    "\072\041\110\045\112\001\002\000\024\012\071\013\uffc2" +
    "\032\105\033\106\034\076\035\115\040\072\041\110\045" +
    "\122\001\002\000\024\012\071\013\uffc3\032\105\033\106" +
    "\034\076\035\115\040\072\041\110\045\122\001\002\000" +
    "\030\012\uffc4\013\uffc4\030\uffc4\032\uffc4\033\uffc4\034\uffc4" +
    "\035\uffc4\040\uffc4\041\uffc4\042\uffc4\045\uffc4\001\002\000" +
    "\006\015\uffdc\017\uffdc\001\002\000\026\012\uffef\031\uffef" +
    "\032\uffef\033\uffef\034\uffef\035\uffef\040\uffef\041\uffef\044" +
    "\uffef\045\uffef\001\002\000\004\014\301\001\002\000\004" +
    "\014\272\001\002\000\004\015\273\001\002\000\004\012" +
    "\274\001\002\000\026\012\uffdb\031\uffdb\032\uffdb\033\uffdb" +
    "\034\uffdb\035\uffdb\040\uffdb\041\uffdb\043\uffdb\045\uffdb\001" +
    "\002\000\026\012\ufff8\031\ufff8\032\ufff8\033\ufff8\034\ufff8" +
    "\035\ufff8\040\ufff8\041\ufff8\043\017\045\ufff8\001\002\000" +
    "\004\013\uffda\001\002\000\004\013\300\001\002\000\004" +
    "\002\uffd9\001\002\000\010\015\ufff8\031\054\045\050\001" +
    "\002\000\004\015\303\001\002\000\004\012\304\001\002" +
    "\000\026\012\uffe4\031\uffe4\032\uffe4\033\uffe4\034\uffe4\035" +
    "\uffe4\040\uffe4\041\uffe4\043\uffe4\045\uffe4\001\002\000\026" +
    "\012\ufff8\031\ufff8\032\ufff8\033\ufff8\034\ufff8\035\ufff8\040" +
    "\ufff8\041\ufff8\043\017\045\ufff8\001\002\000\004\013\uffe3" +
    "\001\002\000\004\013\310\001\002\000\006\031\uffe2\044" +
    "\uffe2\001\002\000\004\002\ufffc\001\002\000\004\002\uffe9" +
    "\001\002\000\004\045\314\001\002\000\004\014\045\001" +
    "\002\000\012\031\ufffa\043\ufffa\044\ufffa\045\ufffa\001\002" +
    "\000\004\046\317\001\002\000\004\016\320\001\002\000" +
    "\014\027\ufff7\031\ufff7\043\ufff7\044\ufff7\045\ufff7\001\002" +
    "\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\317\000\006\002\003\055\004\001\001\000\002\001" +
    "\001\000\006\003\006\056\005\001\001\000\012\004\010" +
    "\006\013\015\012\016\011\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\006\013\015\314" +
    "\016\011\001\001\000\010\006\017\017\014\020\015\001" +
    "\001\000\002\001\001\000\014\005\033\007\035\010\034" +
    "\022\036\023\031\001\001\000\010\006\017\017\030\020" +
    "\015\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\021\025\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\024\167\025\043\001\001\000\002\001\001" +
    "\000\010\005\033\007\311\010\034\001\001\000\002\001" +
    "\001\000\012\005\033\007\310\010\034\023\252\001\001" +
    "\000\002\001\001\000\006\024\041\025\043\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\006\052\012\051\013\054\014\050\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\014\056\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\057\062\001" +
    "\001\000\012\006\017\011\064\017\063\020\015\001\001" +
    "\000\044\022\073\023\031\027\074\030\077\031\101\033" +
    "\117\034\103\035\102\036\076\037\100\040\115\041\072" +
    "\042\067\046\112\047\110\051\106\054\116\001\001\000" +
    "\004\060\065\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\065\257\001\001\000\010\026" +
    "\255\027\127\030\133\001\001\000\002\001\001\000\042" +
    "\023\252\027\074\030\077\031\101\033\253\034\103\035" +
    "\102\036\076\037\100\040\115\041\072\042\067\046\112" +
    "\047\110\051\106\054\116\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\024\167\025" +
    "\043\001\001\000\002\001\001\000\006\024\041\025\043" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\036\027\074\030\077\031\101\034\120\035\102" +
    "\036\076\037\100\040\115\041\072\042\067\046\112\047" +
    "\110\051\106\054\116\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\026\160\027\127\030\133\001\001\000" +
    "\012\026\132\027\127\030\133\050\134\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\026\156\027\127\030" +
    "\133\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\010\026\137\027\127\030\133\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\026\152\027\127\030" +
    "\133\001\001\000\010\026\151\027\127\030\133\001\001" +
    "\000\010\026\150\027\127\030\133\001\001\000\010\026" +
    "\147\027\127\030\133\001\001\000\010\026\146\027\127" +
    "\030\133\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\026\155\027\127\030" +
    "\133\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\026" +
    "\163\027\127\030\133\001\001\000\002\001\001\000\036" +
    "\027\074\030\077\031\101\034\165\035\102\036\076\037" +
    "\100\040\115\041\072\042\067\046\112\047\110\051\106" +
    "\054\116\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\025\172\001\001" +
    "\000\002\001\001\000\010\026\174\027\127\030\133\001" +
    "\001\000\002\001\001\000\036\027\074\030\077\031\101" +
    "\034\176\035\102\036\076\037\100\040\115\041\072\042" +
    "\067\046\112\047\110\051\106\054\116\001\001\000\002" +
    "\001\001\000\036\027\074\030\077\031\101\034\200\035" +
    "\102\036\076\037\100\040\115\041\072\042\067\046\112" +
    "\047\110\051\106\054\116\001\001\000\002\001\001\000" +
    "\014\006\204\026\203\027\127\030\133\053\202\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\006\212\052\210" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\026\221" +
    "\027\127\030\133\001\001\000\010\026\217\027\127\030" +
    "\133\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\026" +
    "\225\027\127\030\133\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\043\230\044\231\001\001\000\010\006" +
    "\243\044\242\045\240\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\031\235\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\031\245\001\001\000\004\066\246\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\036\027\074\030\077" +
    "\031\101\034\120\035\102\036\076\037\100\040\115\041" +
    "\072\042\067\046\112\047\110\051\106\054\116\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\046\022\261\023\031\027\074\030\077\031\101\032\260" +
    "\033\262\034\103\035\102\036\076\037\100\040\115\041" +
    "\072\042\067\046\112\047\110\051\106\054\116\001\001" +
    "\000\002\001\001\000\042\023\252\027\074\030\077\031" +
    "\101\033\263\034\103\035\102\036\076\037\100\040\115" +
    "\041\072\042\067\046\112\047\110\051\106\054\116\001" +
    "\001\000\036\027\074\030\077\031\101\034\120\035\102" +
    "\036\076\037\100\040\115\041\072\042\067\046\112\047" +
    "\110\051\106\054\116\001\001\000\036\027\074\030\077" +
    "\031\101\034\120\035\102\036\076\037\100\040\115\041" +
    "\072\042\067\046\112\047\110\051\106\054\116\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\063\274\001\001\000\012\006\017\011" +
    "\275\017\063\020\015\001\001\000\004\064\276\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\006\052\012" +
    "\301\013\054\014\050\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\061\304\001\001\000\012\006\017\011" +
    "\305\017\063\020\015\001\001\000\004\062\306\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
	int contadorBloque = 0;
	//Lista para almacenar las cadenas de caracteres
	List<QuadrupleIF> listaCadenas = new ArrayList<QuadrupleIF>();


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // opcionesEscribeEnt ::= expresion 
            {
              OpcionesEscribeEnt RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
										if (!(exp.esAritmetica()))
										{
											semanticErrorManager.semanticFatalError("Error, la expresion de EscribeEnt no puede ser logica");
										}
										OpcionesEscribeEnt op = new OpcionesEscribeEnt();
										ScopeIF scope = scopeManager.getCurrentScope();
										TemporalFactoryIF tF = new TemporalFactory(scope);
										IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
										TemporalIF Etemp = exp.getTemporal();
										cb.addQuadruples(exp.getIntermediateCode());
										cb.addQuadruple("ESCRIBENT",Etemp);
										op.setIntermediateCode(cb.create());
										RESULT = op;
										
              CUP$parser$result = parser.getSymbolFactory().newSymbol("opcionesEscribeEnt",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // opcionesEscribeEnt ::= epsilon 
            {
              OpcionesEscribeEnt RESULT =null;
		
							OpcionesEscribeEnt op = new OpcionesEscribeEnt();
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
							cb.addQuadruple("ESCRIBELINEA");
							op.setIntermediateCode(cb.create());
							RESULT = op;
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("opcionesEscribeEnt",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // opcionesEscribe ::= STRING 
            {
              OpcionesEscribe RESULT =null;
		int cadenaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cadenaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token cadena = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							OpcionesEscribe op = new OpcionesEscribe();
							ScopeIF scope = scopeManager.getCurrentScope();
							//Generacion de Codigo Intermedio
							TemporalFactory tF = new TemporalFactory(scope);
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							String texto = cadena.getLexema();
							LabelFactory lF = new LabelFactory();
							LabelIF lb = lF.create();
							TemporalIF temp = tF.create();
							cb.addQuadruple("ESCRIBECADENA", temp, lb);
							//Guardamos la cadena de caracteres en "listaCadena" y la recuperaremos al final del programa principal
							listaCadenas.add(new Quadruple("CADENA", new Label(texto), lb));
							op.setIntermediateCode(cb.create());
							//printamos el código intermedio generado
							System.out.println("Codigo intermedio CADENA: " + op.getIntermediateCode());
							RESULT = op;
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("opcionesEscribe",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // opcionesEscribe ::= epsilon 
            {
              OpcionesEscribe RESULT =null;
		
							OpcionesEscribe op = new OpcionesEscribe();
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
							cb.addQuadruple("ESCRIBELINEA");
							op.setIntermediateCode(cb.create());
							RESULT = op;
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("opcionesEscribe",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // sentenciaSalida ::= ESCRIBE_ENT OPEN_KEY opcionesEscribeEnt CLOSE_KEY SEMI_COLON 
            {
              SentenciaSalida RESULT =null;
		int opcleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int opcright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		OpcionesEscribeEnt opc = (OpcionesEscribeEnt)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
								SentenciaSalida op = new SentenciaSalida();
								ScopeIF scope = scopeManager.getCurrentScope();
								IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
								cb.addQuadruples(opc.getIntermediateCode());
								op.setIntermediateCode(cb.create());
								RESULT = op;
								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaSalida",39, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // sentenciaSalida ::= ESCRIBE OPEN_KEY opcionesEscribe CLOSE_KEY SEMI_COLON 
            {
              SentenciaSalida RESULT =null;
		int opcleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int opcright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		OpcionesEscribe opc = (OpcionesEscribe)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
								SentenciaSalida op = new SentenciaSalida();
								ScopeIF scope = scopeManager.getCurrentScope();
								IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
								cb.addQuadruples(opc.getIntermediateCode());
								op.setIntermediateCode(cb.create());
								RESULT = op;
								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaSalida",39, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // sentenciaLlamadaFuncion ::= llamadaFuncion SEMI_COLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaLlamadaFuncion",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // sentenciaMientras ::= MIENTRAS OPEN_KEY expresion CLOSE_KEY sentencia 
            {
              SentenciaMientras RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia sent = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
																boolean devuelveVacio = false;															
																boolean devuelveResultado = false;
																
																if (!exp.esLogica())
																{
																	semanticErrorManager.semanticFatalError("Expresión de bucle Mientras no es de tipo lógico.");
																}
																
																//Comprobamos si hay sentencia devuelve en el bloque
																ArrayList<Sentencia> array = sent.devuelveSentencias();
																for (int i=0;i<array.size();i++)
																{
																if ((array.get(i).devuelveVacio()))
																	{
																	devuelveVacio = true;
																	}
																if ((array.get(i).devuelveResultado()))
																	{
																	devuelveResultado = true;
																	}
																}
																SentenciaMientras sentencia = new SentenciaMientras();
																if (devuelveVacio)
																{
																	sentencia.setVacioParcial();
																}
																if (devuelveResultado)
																{
																	sentencia.setResultadoParcial();
																}
																
																ScopeIF scope = scopeManager.getCurrentScope();
																
																//Código intermedio
																LabelFactory Mientras = new LabelFactory();
																LabelIF etiquetaFinMientras = Mientras.create(); //Etiqueta para fin de las sentenicas Mientras
																LabelIF etiquetaInicio = Mientras.create(); //Etiqueta para inicio de las sentenicas Mientras
																TemporalIF expTemp = exp.getTemporal();
																IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
																
																cb.addQuadruple("INL", etiquetaInicio); // insertar etiquetaInicio
																cb.addQuadruples(exp.getIntermediateCode()); //añadir el código de la expresión
																cb.addQuadruple("NOP");
																cb.addQuadruple("BRF", expTemp, etiquetaFinMientras); //si no se cumple la condicion salto etiquetaFinMientras
																cb.addQuadruples (sent.getIntermediateCode()); //añadir código sentencias
																cb.addQuadruple("NOP");
																cb.addQuadruple("BR", etiquetaInicio); //salto a la etiquetaInicio
																cb.addQuadruple("NOP");
																cb.addQuadruple("INL", etiquetaFinMientras); // insertar etiquetaFinMientras
																sentencia.setIntermediateCode(cb.create());
																//printamos el código intermedio generado
																System.out.println("Codigo intermedio: " + sentencia.getIntermediateCode());																
													
																RESULT = sentencia;
																
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaMientras",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // porDefecto ::= epsilon 
            {
              PorDefecto RESULT =null;
		
											PorDefecto def = new PorDefecto();
											ScopeIF scope = scopeManager.getCurrentScope();
											IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
											def.setIntermediateCode(cb.create());
											RESULT = def;
											
              CUP$parser$result = parser.getSymbolFactory().newSymbol("porDefecto",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // porDefecto ::= PORDEFECTO TWO_POINTS bloque NT$9 CORTE SEMI_COLON 
            {
              PorDefecto RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (PorDefecto) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int bloqright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Bloque bloq = (Bloque)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("porDefecto",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // NT$9 ::= 
            {
              PorDefecto RESULT =null;
		int bloqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Bloque bloq = (Bloque)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

										boolean devuelveVacio = false;															
										boolean devuelveResultado = false;
										//Comprobamos si hay sentencia devuelve en el bloque
										ArrayList<Sentencia> array = ((Bloque)bloq).devuelveSentencias();
										for (int i=0;i<array.size();i++)
										{
											if ((array.get(i).devuelveVacio()))
												{
												devuelveVacio = true;
												}
											if ((array.get(i).devuelveResultado()))
												{
												devuelveResultado = true;
												}
										}
										PorDefecto def = new PorDefecto();
										if (devuelveVacio)
											{
												def.setVacio();
											}
											if (devuelveResultado)
											{
												def.setResultado();
											}
											//CODIGO INTERMEDIO
											ScopeIF scope = scopeManager.getCurrentScope();
											IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
											cb.addQuadruples(bloq.getIntermediateCode());
											def.setIntermediateCode(cb.create());
																
											RESULT = def;
											
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$9",52, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // casoAlt ::= CASO NUMERO TWO_POINTS bloque CORTE SEMI_COLON 
            {
              CasoAlt RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bloqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bloqright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Bloque bloq = (Bloque)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
										boolean devuelveVacio = false;															
										boolean devuelveResultado = false;
										int val = Integer.parseInt(num.getLexema());
										//Comprobamos si hay sentencia devuelve en el bloque
										ArrayList<Sentencia> array = ((Bloque)bloq).devuelveSentencias();
										for (int i=0;i<array.size();i++)
										{
											if ((array.get(i).devuelveVacio()))
												{
												devuelveVacio = true;
												}
											if ((array.get(i).devuelveResultado()))
												{
												devuelveResultado = true;
												}
										}
										CasoAlt caso = new CasoAlt();
										if (devuelveVacio)
											{
												caso.setVacio();
											}
											if (devuelveResultado)
											{
												caso.setResultado();
											}	
										caso.setNumero(val);
										//CODIGO INTERMEDIO
										ScopeIF scope = scopeManager.getCurrentScope();
										IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
										cb.addQuadruples(bloq.getIntermediateCode());
										caso.setIntermediateCode(cb.create());
										RESULT = caso;
										
										
              CUP$parser$result = parser.getSymbolFactory().newSymbol("casoAlt",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // casosAlternativa ::= casoAlt 
            {
              CasosAlternativa RESULT =null;
		int altleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int altright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CasoAlt alt = (CasoAlt)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									CasosAlternativa casos = new CasosAlternativa();
									casos.addCaso(alt);
									ScopeIF scope = scopeManager.getCurrentScope();
									IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
									cb.addQuadruples(alt.getIntermediateCode());
									casos.setIntermediateCode(cb.create());
									RESULT = casos;
									
              CUP$parser$result = parser.getSymbolFactory().newSymbol("casosAlternativa",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // casosAlternativa ::= casosAlternativa casoAlt 
            {
              CasosAlternativa RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		CasosAlternativa lista = (CasosAlternativa)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int altleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int altright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CasoAlt alt = (CasoAlt)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									CasosAlternativa casos = new CasosAlternativa();
									ArrayList<CasoAlt> listado = new ArrayList<>();
									listado = lista.devolverCasos();
									casos.actualizarCasos(listado);
									casos.addCaso(alt);
									ScopeIF scope = scopeManager.getCurrentScope();
									IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
									cb.addQuadruples(lista.getIntermediateCode());
									cb.addQuadruples(alt.getIntermediateCode());
									casos.setIntermediateCode(cb.create());
									RESULT = casos;
									
              CUP$parser$result = parser.getSymbolFactory().newSymbol("casosAlternativa",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sentenciaAlternativas ::= ALTENATIVAS OPEN_KEY expresion CLOSE_KEY OPEN_PARENTHESIS casosAlternativa porDefecto CLOSE_PARENTHESIS 
            {
              SentenciaAlternativas RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int altleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int altright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		CasosAlternativa alt = (CasosAlternativa)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int defleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int defright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		PorDefecto def = (PorDefecto)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
									boolean devuelveVacio = false;															
									boolean devuelveResultado = false;
									int contador = 0;
									ArrayList<CasoAlt> casos = new ArrayList<>();
									
									//Comprobamos si la expresión es aritmetica
									if (!exp.esAritmetica())
										{
											semanticErrorManager.semanticFatalError("Expresión de Sentencia Alternativas no es de tipo aritmetico.");
										}
									casos = alt.devolverCasos();
									for (int i=0;i<casos.size();i++)
									{
										if (casos.get(i).devuelveVacio())
										{
											devuelveVacio = true;
											contador++;
										}
										if (casos.get(i).devuelveResultado())
										{
											devuelveResultado = true;
											contador++;
										}
									}
									if ((contador != casos.size())&& ((devuelveVacio || devuelveResultado)))
									{
										semanticErrorManager.semanticFatalError("Faltan sentencias Devuelve en la sentencia alternativas");
									}
									if ((devuelveVacio == devuelveResultado)&&(devuelveVacio == true))
									{
										semanticErrorManager.semanticFatalError("Error en el tipo de la sentencia Devuelve de sentencia alternativas");
									}
									if (((devuelveVacio) && (def.devuelveResultado())) || ((devuelveResultado) && (def.devuelveVacio())))
									{
										semanticErrorManager.semanticFatalError("Error en el tipo de la sentencia Devuelve de sentencia alternativas");
									}
									if ((!(def.devuelveResultado()) && (!(def.devuelveVacio()))) && ((devuelveVacio) || (devuelveResultado)))
									{
										semanticErrorManager.semanticFatalError("Falta sentencia Devuelve en seccion pordefecto de sentencia alternativas");
									}
									SentenciaAlternativas sent = new SentenciaAlternativas();
									if (devuelveVacio)
									{
										sent.setVacio();
									}
									if (devuelveResultado)
									{
										sent.setResultado();
									}
									
									//Codigo intermedio
									ScopeIF scope = scopeManager.getCurrentScope();
									LabelFactory Alt = new LabelFactory();
									ArrayList<LabelIF> etiquetas = new ArrayList<>();
									int contador1 = 0;
									for (int i=0;i<casos.size();i++)
									{
										
										etiquetas.add(Alt.create());
										contador1 = i;
									}
									etiquetas.add(Alt.create());
									contador1 = contador1+1;
									TemporalFactoryIF tF = new TemporalFactory(scope);
									IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
									
									TemporalIF temp = tF.create();
									for (int i=0;i<casos.size();i++)
									{
										cb.addQuadruples(exp.getIntermediateCode()); //añadir el código de la expresión
										TemporalIF expTemp = exp.getTemporal();
										int num = casos.get(i).getNumero();
										cb.addQuadruple("SUB",temp,expTemp,num);
										cb.addQuadruple("BRT",temp, etiquetas.get(i).getName());
										cb.addQuadruples(casos.get(i).getIntermediateCode());
										cb.addQuadruple("BR", etiquetas.get(contador1).getName());
										cb.addQuadruple("INL", etiquetas.get(i).getName());
									}
									cb.addQuadruples(def.getIntermediateCode());
									cb.addQuadruple("INL", etiquetas.get(contador1).getName());
									sent.setIntermediateCode(cb.create());
									RESULT = sent;
									
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaAlternativas",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentenciaSi ::= SI OPEN_KEY expresion CLOSE_KEY sentencia 
            {
              SentenciaSi RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia sent = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
																boolean devuelveVacio = false;															
																boolean devuelveResultado = false;
																
																//Comprobamos si la expresión es lógica
																if (!exp.esLogica())
																{
																	semanticErrorManager.semanticFatalError("Expresión de condicional Si no es de tipo lógico.");
																}
																
																//Comprobamos si hay sentencia devuelve en el bloque
																ArrayList<Sentencia> array = sent.devuelveSentencias();
																for (int i=0;i<array.size();i++)
																{
																if ((array.get(i).devuelveVacio()))
																	{
																	devuelveVacio = true;
																	}
																if ((array.get(i).devuelveResultado()))
																	{
																	devuelveResultado = true;
																	}
																}
																SentenciaSi sentencia = new SentenciaSi();
																if (devuelveVacio)
																{
																	sentencia.setVacioParcial();
																}
																if (devuelveResultado)
																{
																	sentencia.setResultadoParcial();
																}
																
																ScopeIF scope = scopeManager.getCurrentScope();
																
																//Código intermedio
																LabelFactory Si = new LabelFactory();
																LabelIF etiquetaFinSi = Si.create(); //Etiqueta para fin de las sentenicas Si
																TemporalIF expTemp = exp.getTemporal();
																IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
																cb.addQuadruples(exp.getIntermediateCode()); //añadir el código de la expresión
																cb.addQuadruple("BRF", expTemp, etiquetaFinSi); //si no se cumple la condicion salto etiquetaFinSi
																cb.addQuadruples (sent.getIntermediateCode()); //añadir código sentencias parte Si
																cb.addQuadruple("INL", etiquetaFinSi); // insertar etiquetaFinSi
																sentencia.setIntermediateCode(cb.create());
																//printamos el código intermedio generado
																System.out.println("Codigo intermedio: " + sentencia.getIntermediateCode());																
																RESULT = sentencia;
																
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaSi",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // sentenciaSi ::= SI OPEN_KEY expresion CLOSE_KEY sentencia SINO sentencia 
            {
              SentenciaSi RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sent1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sent1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Sentencia sent1 = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sent2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sent2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia sent2 = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
																boolean devuelveVacio1 = false;
																boolean devuelveVacio2 = false;
																boolean devuelveResultado1 = false;
																boolean devuelveResultado2 = false;
																
																//Comprobamos si la expresión es lógica
																if (!exp.esLogica())
																{
																	semanticErrorManager.semanticFatalError("Expresión de condicional si-sino no es de tipo lógico.");
																}
																
																//Comprobamos que si hay devuelve en bloque si también lo hay en bloque sino
																ArrayList<Sentencia> array1 = sent1.devuelveSentencias();
																for (int i=0;i<array1.size();i++)
																{
																if ((array1.get(i).devuelveVacio()))
																	{
																	devuelveVacio1 = true;
																	}
																if ((array1.get(i).devuelveResultado()))
																	{
																	devuelveResultado1 = true;
																	}
																}
																ArrayList<Sentencia> array2 = sent2.devuelveSentencias();
																for (int i=0;i<array2.size();i++)
																{
																if ((array2.get(i).devuelveVacio()))
																	{
																	devuelveVacio2 = true;														
																	}
																if ((array2.get(i).devuelveResultado()))
																	{
																	devuelveResultado2 = true;
																	}
																}
																if ((devuelveVacio1 && devuelveResultado2) || (devuelveVacio2 && devuelveResultado1))
																{
																	semanticErrorManager.semanticFatalError("Sentencia Devuelve en sentencia condicional si-sino devuelve tipo equivocado");
																}
																if (((devuelveVacio1 && !(devuelveVacio2))) || (devuelveResultado1 && !(devuelveResultado2)))
																{
																	semanticErrorManager.semanticFatalError("Falta sentencia Devuelve en sentencia condicional si-sino");
																}
																if (((devuelveVacio2 && !(devuelveVacio1))) || (devuelveResultado2 && !(devuelveResultado1)))
																{
																	semanticErrorManager.semanticFatalError("Falta sentencia Devuelve en sentencia condicional si-sino");
																}
																SentenciaSi sentencia = new SentenciaSi();
																if (devuelveVacio1)
																{
																	sentencia.setVacio();
																}
																if (devuelveResultado1)
																{
																	sentencia.setResultado();
																}
																
																ScopeIF scope = scopeManager.getCurrentScope();

																//Código intermedio
																LabelFactory Si = new LabelFactory();
																LabelIF etiquetaFinSi = Si.create(); //Etiqueta para fin de las sentenicas Si
																LabelIF etiquetaSino = Si.create(); //Etiqueta de comienzo parte Sino
																TemporalIF expTemp = exp.getTemporal();
																IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
																cb.addQuadruples(exp.getIntermediateCode()); //añadir el código de la expresión
																cb.addQuadruple("BRF", expTemp, etiquetaSino); //si no se cumple la condicion salto etiquetaSino
																cb.addQuadruples (sent1.getIntermediateCode()); //añadir código sentencias parte Si
																cb.addQuadruple("BR", etiquetaFinSi); //salto a la etiquetaFinSi
																cb.addQuadruple("INL", etiquetaSino); //insertar etiquetaSino
																cb.addQuadruples(sent2.getIntermediateCode()); //añadir código sentencias parte Sino
																cb.addQuadruple("INL", etiquetaFinSi); // insertar etiquetaFinSi
																sentencia.setIntermediateCode(cb.create());
																//printamos el código intermedio generado
																System.out.println("Codigo intermedio: " + sentencia.getIntermediateCode());
																RESULT = sentencia;
																
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaSi",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // sentenciaAsignacionSuma ::= ref ASSIGN_SUMA expresion SEMI_COLON 
            {
              SentenciaAsignacionSuma RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Ref id = (Ref)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			if (!(e.esAritmetica()))
			{
				semanticErrorManager.semanticFatalError("Error al intentar asignar y sumar una expresion logica.");
			}
			//CODIGO INTERMEDIO
			
			SentenciaAsignacionSuma sen = new SentenciaAsignacionSuma();
			ScopeIF scope = scopeManager.getCurrentScope();
			TemporalFactoryIF tF = new TemporalFactory(scope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			cb.addQuadruples(id.getIntermediateCode());
			cb.addQuadruples(e.getIntermediateCode());
			TemporalIF temp = tF.create();
			TemporalIF temp2 = tF.create();
			TemporalIF eTemp = e.getTemporal();
			TemporalIF tempRef = id.getTemporal();
			cb.addQuadruple("MVP", temp, tempRef);
			//Sumamos esto al contenido de la expresion
			cb.addQuadruple("ADD", temp2, temp, eTemp);
			//Almacenamos puntero al contenido
			cb.addQuadruple("STP", tempRef, temp2);
			sen.setIntermediateCode(cb.create());
			//printamos el código intermedio generado
			System.out.println("Codigo intermedio asignacion suma: " + sen.getIntermediateCode());
			RESULT = sen;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaAsignacionSuma",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // ref ::= accesoVector 
            {
              Ref RESULT =null;
		int avleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int avright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AccesoVector av = (AccesoVector)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			Ref ref = new Ref();
			ScopeIF scope = scopeManager.getCurrentScope();
			TemporalFactoryIF tF = new TemporalFactory(scope);
			TemporalIF temp = av.getTemporal();
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			cb.addQuadruples(av.getIntermediateCode());
			ref.setIntermediateCode(cb.create());
			ref.setTemporal(temp);
			RESULT = ref;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ref",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // ref ::= IDENTIFICADOR 
            {
              Ref RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			//Comprobamos que el identificador exista en los ámbitos abiertos
			if (!scopeManager.containsSymbol(id.getLexema()))
			{
				semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " no existe en los ambitos abiertos.");
			}
			//Obtenemos símbolo
			SymbolIF sim = scopeManager.searchSymbol(id.getLexema());
			//Comprobamos si es una constante
			if (sim instanceof SymbolConstant)
			{
				semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " es una constante y no se puede asignar ningun valor.");
			}
			//Si es una función
			else if (sim instanceof SymbolFunction)
			{
				semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " es de una funcion y no se puede asignar ningun valor.");
			}
			Ref ref = new Ref(id.getLexema());
			ScopeIF scope = scopeManager.getCurrentScope();
			TemporalFactoryIF tF = new TemporalFactory(scope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			TemporalIF temp = tF.create();
			Variable var = new Variable(id.getLexema(), sim.getScope());
			cb.addQuadruple("MVA", temp, var);
			ref.setIntermediateCode(cb.create());
			ref.setTemporal(temp);
			RESULT = ref;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ref",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // sentenciaAsignacion ::= ref ASSIGN expresion SEMI_COLON 
            {
              SentenciaAsignacion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Ref id = (Ref)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			
			//CODIGO INTERMEDIO
			
			SentenciaAsignacion sen = new SentenciaAsignacion();
			ScopeIF scope = scopeManager.getCurrentScope();
			TemporalFactoryIF tF = new TemporalFactory(scope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			cb.addQuadruples(id.getIntermediateCode());
			cb.addQuadruples(e.getIntermediateCode());
			TemporalIF rtemp = id.getTemporal();
			TemporalIF eTemp = e.getTemporal();
			cb.addQuadruple("STP", rtemp, eTemp);
			sen.setIntermediateCode(cb.create());
			//printamos el código intermedio generado
			System.out.println("Codigo intermedio asignacion: " + sen.getIntermediateCode());
			RESULT = sen;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaAsignacion",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // sentenciaIncremento ::= IDENTIFICADOR AUTO_INCREMENTO SEMI_COLON 
            {
              SentenciaIncremento RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
						//Obtenemos ambito
						ScopeIF scope = scopeManager.getCurrentScope();
						//Comprobamos que el identificador exista en los ámbitos abiertos
						if (!scopeManager.containsSymbol(id.getLexema()))
						{
							semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " no existe en los ambitos abiertos.");
						}
						//Obtenemos símbolo
						SymbolIF sim = scopeManager.searchSymbol(id.getLexema());
						//Comprobamos si es una constante
						if (sim instanceof SymbolConstant)
						{
							semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " es una constante y no se puede incrementar.");
						}
						//Si es una función
						else if (sim instanceof SymbolFunction)
						{
							semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " es de una funcion y no se puede incrementar.");
						}
						
						//CODIGO INTERMEDIO
						SentenciaIncremento sen = new SentenciaIncremento();
						TemporalFactoryIF tF = new TemporalFactory(scope);
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp = tF.create();
						TemporalIF temp2 = tF.create();
						Variable var = new Variable(id.getLexema(), sim.getScope());
						//Obtenemos puntero al contenido de var
						cb.addQuadruple("MV", temp, var);
						//Incrementamos contenido
						cb.addQuadruple("INC", temp);
						//Obtenemos direccion de var
						cb.addQuadruple("MVA", temp2, var);
						//Almacenamos su contenido en su direccion
						cb.addQuadruple("STP", temp2, temp);
						sen.setIntermediateCode(cb.create());
						RESULT = sen;
						//printamos el código intermedio generado
						System.out.println("Codigo intermedio sen aut: " + sen.getIntermediateCode());
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaIncremento",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // sentenciaDevuelve ::= DEVUELVE expresion SEMI_COLON 
            {
              SentenciaDevuelve RESULT =null;
		
					SentenciaDevuelve sent = new SentenciaDevuelve();
					sent.setResultado();
					RESULT = sent;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaDevuelve",42, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // sentenciaDevuelve ::= DEVUELVE SEMI_COLON 
            {
              SentenciaDevuelve RESULT =null;
		
					SentenciaDevuelve sent = new SentenciaDevuelve();
					sent.setVacio();
					RESULT = sent;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaDevuelve",42, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // sentencia ::= bloque 
            {
              Sentencia RESULT =null;
		int bloqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Bloque bloq = (Bloque)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			Sentencia senten = new Sentencia();
			senten.setBloque();
			ArrayList<Sentencia> list = ((Bloque)bloq).devuelveSentencias();
			senten.actualizaSentencias(list);
			
			ScopeIF scope = scopeManager.getCurrentScope();
			senten.setScope(scope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			cb.addQuadruples(bloq.getIntermediateCode());
			senten.setIntermediateCode(cb.create());
			RESULT = senten;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // sentencia ::= sentenciaSalida 
            {
              Sentencia RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaSalida sent = (SentenciaSalida)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia senten = new Sentencia();
	ScopeIF scope = scopeManager.getCurrentScope();
	senten.setScope(scope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(sent.getIntermediateCode());
	senten.setIntermediateCode(cb.create());
	RESULT = senten;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // sentencia ::= sentenciaLlamadaFuncion 
            {
              Sentencia RESULT =null;
		
	Sentencia senten = new Sentencia();
	ScopeIF scope = scopeManager.getCurrentScope();
	senten.setScope(scope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	senten.setIntermediateCode(cb.create());
	RESULT = senten;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // sentencia ::= sentenciaMientras 
            {
              Sentencia RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaMientras sent = (SentenciaMientras)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia senten = new Sentencia();
		if (sent.devuelveVacio())
		{	
			senten.setVacio();
		}
		if (sent.devuelveResultado())
		{
			senten.setResultado();
		}
		if (sent.devuelveVacioParcial())
		{	
			senten.setVacioParcial();
		}
		if (sent.devuelveResultadoParcial())
		{
			senten.setResultadoParcial();
		}
		senten.setDevuelve();
		ScopeIF scope = scopeManager.getCurrentScope();
		senten.setScope(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		cb.addQuadruples(sent.getIntermediateCode());
		senten.setIntermediateCode(cb.create());
		RESULT = senten;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // sentencia ::= sentenciaAlternativas 
            {
              Sentencia RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaAlternativas sent = (SentenciaAlternativas)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia senten = new Sentencia();
	if (sent.devuelveVacio())
		{	
			senten.setVacio();
		}
		if (sent.devuelveResultado())
		{
			senten.setResultado();
		}
		ScopeIF scope = scopeManager.getCurrentScope();
		senten.setScope(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		cb.addQuadruples(sent.getIntermediateCode());
		senten.setIntermediateCode(cb.create());
	RESULT = senten;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // sentencia ::= sentenciaSi 
            {
              Sentencia RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaSi sent = (SentenciaSi)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia senten = new Sentencia();
		if (sent.devuelveVacio())
		{	
			senten.setVacio();
		}
		if (sent.devuelveResultado())
		{
			senten.setResultado();
		}
		if (sent.devuelveVacioParcial())
		{	
			senten.setVacioParcial();
		}
		if (sent.devuelveResultadoParcial())
		{
			senten.setResultadoParcial();
		}
		senten.setDevuelve();
		ScopeIF scope = scopeManager.getCurrentScope();
		senten.setScope(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		cb.addQuadruples(sent.getIntermediateCode());
		senten.setIntermediateCode(cb.create());
		RESULT = senten;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // sentencia ::= sentenciaAsignacionSuma 
            {
              Sentencia RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaAsignacionSuma sen = (SentenciaAsignacionSuma)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia senten = new Sentencia();
	ScopeIF scope = scopeManager.getCurrentScope();
	senten.setScope(scope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(sen.getIntermediateCode());
	senten.setIntermediateCode(cb.create());
	RESULT = senten;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // sentencia ::= sentenciaAsignacion 
            {
              Sentencia RESULT =null;
		int senleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int senright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaAsignacion sen = (SentenciaAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia senten = new Sentencia();
	ScopeIF scope = scopeManager.getCurrentScope();
	senten.setScope(scope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(sen.getIntermediateCode());
	senten.setIntermediateCode(cb.create());
	RESULT = senten;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // sentencia ::= sentenciaIncremento 
            {
              Sentencia RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaIncremento sent = (SentenciaIncremento)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Sentencia senten = new Sentencia();
	ScopeIF scope = scopeManager.getCurrentScope();
	senten.setScope(scope);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	cb.addQuadruples(sent.getIntermediateCode());
	senten.setIntermediateCode(cb.create());
	RESULT = senten;
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // sentencia ::= sentenciaDevuelve 
            {
              Sentencia RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaDevuelve sent = (SentenciaDevuelve)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		Sentencia senten = new Sentencia();
		if (sent.devuelveVacio())
		{
			senten.setVacio();
		}
		else
		{
			senten.setResultado();
		}
		senten.setDevuelve();
		RESULT = senten;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // listadoSentencias ::= sentencia 
            {
              ListadoSentencias RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia sent = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
													ListadoSentencias lista = new ListadoSentencias();
													if (sent.esBloque())
													{
														ArrayList<Sentencia> array = sent.devuelveSentencias();
														for (int i=0;i<array.size();i++)
														{
															lista.addSentencia(array.get(i));
														}
													}
													else 
													{
														lista.addSentencia(sent);													
													}
													ScopeIF scope = scopeManager.getCurrentScope();
													IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
													cb.addQuadruples(sent.getIntermediateCode());
													lista.setIntermediateCode(cb.create());
													
													RESULT = lista;
												
              CUP$parser$result = parser.getSymbolFactory().newSymbol("listadoSentencias",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // listadoSentencias ::= listadoSentencias sentencia 
            {
              ListadoSentencias RESULT =null;
		int listadoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listadoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListadoSentencias listado = (ListadoSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia sent = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
													ListadoSentencias lista = new ListadoSentencias();
													ArrayList<Sentencia> list = listado.devuelveSentencias();
													lista.actualizaSentencias(list);
													if (sent.esBloque())
													{
														ArrayList<Sentencia> array = sent.devuelveSentencias();
														for (int i=0;i<array.size();i++)
														{
															lista.addSentencia(array.get(i));
														}
													}
													else 
													{
														lista.addSentencia(sent);
													}
													lista.addSentencia(sent);
													ScopeIF scope = scopeManager.getCurrentScope();
													IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
													cb.addQuadruples(listado.getIntermediateCode());
													cb.addQuadruples(sent.getIntermediateCode());
													lista.setIntermediateCode(cb.create());
													RESULT = lista;
												
												
              CUP$parser$result = parser.getSymbolFactory().newSymbol("listadoSentencias",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // cuerpoBloque ::= listadoSentencias 
            {
              CuerpoBloque RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListadoSentencias lista = (ListadoSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
												CuerpoBloque cuerpo = new CuerpoBloque();
												ArrayList<Sentencia> list = lista.devuelveSentencias();
												cuerpo.actualizaSentencias(list);												
												ScopeIF scope = scopeManager.getCurrentScope();
												IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
												cb.addQuadruples(lista.getIntermediateCode());
												cuerpo.setIntermediateCode(cb.create());
												RESULT = cuerpo;
												
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpoBloque",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // cuerpoBloque ::= seccionVariables listadoSentencias 
            {
              CuerpoBloque RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListadoSentencias lista = (ListadoSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
												CuerpoBloque cuerpo = new CuerpoBloque();
												ArrayList<Sentencia> list = lista.devuelveSentencias();
												cuerpo.actualizaSentencias(list);
												
												ScopeIF scope = scopeManager.getCurrentScope();
												IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
												cb.addQuadruples(lista.getIntermediateCode());
												cuerpo.setIntermediateCode(cb.create());
												RESULT = cuerpo;
												
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpoBloque",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // bloque ::= OPEN_PARENTHESIS NT$8 cuerpoBloque CLOSE_PARENTHESIS 
            {
              Bloque RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Bloque) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		CuerpoBloque cuerpo = (CuerpoBloque)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
					Bloque bloque = new Bloque();
					ArrayList<Sentencia> list = cuerpo.devuelveSentencias();
					bloque.actualizaSentencias(list);
					
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					cb.addQuadruples(cuerpo.getIntermediateCode());
					bloque.setIntermediateCode(cb.create());
					RESULT = bloque;
					
					//cerramos el ambito del bloque
					scopeManager.closeScope();
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // NT$8 ::= 
            {
              Bloque RESULT =null;

					//creamos el ambito del bloque
					ScopeIF scope = scopeManager.getCurrentScope();
					scopeManager.openScope(scope.getName() + "-bloque-" + contadorBloque);
					contadorBloque++;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$8",51, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // parametros ::= parametros COLON expresion 
            {
              Object RESULT =null;
		int parleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int parright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object par = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				Parametros lista = new Parametros();
				if (exp.esIdentificador())
				{
					String id = exp.getLexema();
					if (!scopeManager.containsSymbol(id))
						{
							semanticErrorManager.semanticFatalError("El símbolo "+ id + " que se intenta pasar como parámetro no existe en los ámbitos abiertos.");
						}
					SymbolIF sim = scopeManager.searchSymbol(id);
					//Comprobamos que es una variable
					if (!(sim instanceof SymbolVariable))
						{
							semanticErrorManager.semanticFatalError("El símbolo "+ id + " que pasamos como parámetro no es una variable.");
						}
					//Obtenemos su tipo
					TypeIF tipo = sim.getType();
					//Comprobamos si el tipo es entero al ser una expresion
					if (!(tipo.getName().equals("ENTERO")))
						{
							semanticErrorManager.semanticFatalError("El tipo "+ tipo.getName() +" del identificador " + id + " no es entero y es un parametro que pasamos a una funcion.");
						}
				}
				int contador = ((Parametros)par).getParam();
				lista.actualizaParam(contador);
				lista.sumarParam();
				RESULT = lista;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // parametros ::= expresion 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				Parametros lista = new Parametros();
				if (exp.esIdentificador())
				{
					String id = exp.getLexema();
					if (!scopeManager.containsSymbol(id))
						{
							semanticErrorManager.semanticFatalError("El símbolo "+ id + " que se intenta pasar como parámetro no existe en los ámbitos abiertos.");
						}
					SymbolIF sim = scopeManager.searchSymbol(id);
					//Comprobamos que es una variable
					if (!(sim instanceof SymbolVariable))
						{
							semanticErrorManager.semanticFatalError("El símbolo "+ id + " que pasamos como parámetro no es una variable.");
						}
					//Obtenemos su tipo
					TypeIF tipo = sim.getType();
					//Comprobamos si el tipo es entero al ser una expresion
					if (!(tipo.getName().equals("ENTERO")))
						{
							semanticErrorManager.semanticFatalError("El tipo "+ tipo.getName() +" del identificador " + id + " no es entero y es un parametro que pasamos a una funcion.");
						}
				}
				lista.sumarParam();
				RESULT = lista;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // llamadaFuncion ::= IDENTIFICADOR OPEN_KEY CLOSE_KEY 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
				//Comprobamos que el identificador de la función exista en los ámbitos abiertos
				if (!scopeManager.containsSymbol(id.getLexema()))
				{
					semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " no existe en los ambitos abiertos.");
				}
				//Obtenemos símbolo
				SymbolIF sim = scopeManager.searchSymbol(id.getLexema());
				//Comprobamos que es una funcion
				if (!(sim instanceof SymbolFunction))
				{
					semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " no es una funcion.");
				}
				//Obtenemos su tipo
				TypeIF tipo = sim.getType();
				//Comprobamos si el tipo es entero al ser una expresion
				if (!(tipo.getName().equals("ENTERO")))
				{
					semanticErrorManager.semanticFatalError("El tipo "+ tipo.getName() +" del identificador " + id.getLexema() + " no es entero y es una funcion en contexto de expresion.");
				}
				Expresion exp = new Expresion();
				exp.setFuncion();
				RESULT = exp;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaFuncion",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // llamadaFuncion ::= IDENTIFICADOR OPEN_KEY parametros CLOSE_KEY 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int parleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int parright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object par = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				//Comprobamos que el identificador de la función exista en los ámbitos abiertos
				if (!scopeManager.containsSymbol(id.getLexema()))
				{
					semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " no existe en los ambitos abiertos.");
				}
				//Obtenemos símbolo
				SymbolIF sim = scopeManager.searchSymbol(id.getLexema());
				//Comprobamos que es una funcion
				if (!(sim instanceof SymbolFunction))
				{
					semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " no es una funcion.");
				}
				//Obtenemos su tipo
				TypeIF tipo = sim.getType();
				//Comprobamos si el tipo es entero al ser una expresion
				if (!(tipo.getName().equals("ENTERO")))
				{
					semanticErrorManager.semanticFatalError("El tipo "+ tipo.getName() +" del identificador " + id.getLexema() + " no es entero y es una funcion en contexto de expresion.");
				}
				//Comprobamos que el número de parametros que recibe la funcion sea correcto
				int parametrosPasados = ((Parametros)par).getParam();
				int parametrosDeclarados = ((SymbolFunction)sim).cuentaParametros();
				if (parametrosDeclarados != parametrosPasados)
				{
					semanticErrorManager.semanticFatalError("El numero de parametros de la funcion " + id.getLexema() + " no es correcto.");
				}
				
				
				Expresion exp = new Expresion();
				exp.setFuncion();
				RESULT = exp;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadaFuncion",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // accesoVector ::= IDENTIFICADOR OPEN_BRACKET expresion CLOSE_BRACKET 
            {
              AccesoVector RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion ex = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				//Comprobamos que el identificador del tipo vector exista en los ámbitos abiertos
				if (!scopeManager.containsSymbol(id.getLexema()))
				{
					semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " no existe en los ambitos abiertos.");
				}
				//Obtenemos símbolo
				SymbolIF sim = scopeManager.searchSymbol(id.getLexema());
				//Comprobamos que es una variable o un parámetro
				if ((!(sim instanceof SymbolVariable)) && (!(sim instanceof SymbolParameter)))
				{
					semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " no es una variable o un parametro.");
				}
				//Obtenemos su tipo
				TypeIF tipo = sim.getType();
				//Comprobamos si el tipo existe en los ambitos abiertos y no es entero ni vacio
				if (!scopeManager.containsType(tipo)|| (tipo.getName().equals("ENTERO")) || (tipo.getName().equals("VACIO")))
				{
					semanticErrorManager.semanticFatalError("El tipo "+ tipo.getName() +" del identificador " + id.getLexema() + " no existe en los ambitos abiertos o no es un vector.");
				}
				//Comprobamos que la expresion esta en el rango del tipo del vector
				int rangoMax = tipo.getSize();
				if (((Expresion)ex).getNumero() ||((Expresion)ex).getConstante() )
				{
					int acceso = ((Expresion)ex).getValor();
					if (acceso > (rangoMax-1))
						{
							semanticErrorManager.semanticFatalError("Error en el indice de acceso al vector "+ id.getLexema() + ". El acceso debe ser de 0 a " + (rangoMax-1));
						}
				}
				
				AccesoVector exp = new AccesoVector();
				ScopeIF scope = scopeManager.getCurrentScope();
		
				//GENERACION DE CODIGO INTERMEDIO
				TemporalFactory tF = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				//añadir al codigo intermedio las cuadruplas de la expresiones
				cb.addQuadruples (ex.getIntermediateCode());
				TemporalIF temp1 = tF.create();
				TemporalIF temp2 = tF.create();
				//Temporal para el desplazamiento (índice vector), para candidato[1] su desplazamiento será 0
				TemporalIF tempPosicion = ex.getTemporal();
				Variable var = new Variable(id.getLexema(), sim.getScope());
				cb.addQuadruple("MVA", temp1, var); //dirección base de la variable
				cb.addQuadruple("SUB", temp2, temp1, tempPosicion);
				exp.setTemporal(temp2);
				exp.setIntermediateCode (cb.create());
				//printamos el código intermedio generado (opcional)
				System.out.println("Codigo intermedio acceso: " + exp.getIntermediateCode());
				RESULT = exp;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("accesoVector",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // expresion ::= llamadaFuncion 
            {
              Expresion RESULT =null;
		
		Expresion exp = new Expresion();
		//GENERACION DE CODIGO INTERMEDIO
		ScopeIF scope = scopeManager.getCurrentScope();
		TemporalFactory tF = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		TemporalIF temp1 = tF.create();
		exp.setTemporal(temp1);
		exp.setIntermediateCode(cb.create());
		exp.setAritmetica();
		RESULT = exp;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // expresion ::= accesoVector 
            {
              Expresion RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AccesoVector e = (AccesoVector)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		Expresion exp = new Expresion();
		exp.setAritmetica();
		//GENERACION DE CODIGO INTERMEDIO
		ScopeIF scope = scopeManager.getCurrentScope();
		TemporalFactory tF = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		cb.addQuadruples(e.getIntermediateCode());
		TemporalIF temp = e.getTemporal();
		TemporalIF temp1 = tF.create();
		cb.addQuadruple("MVP", temp1, temp) ;
		exp.setIntermediateCode(cb.create());
		exp.setTemporal(temp1);
		//printamos el código intermedio generado
		System.out.println("Codigo intermedio exp acceso: " + exp.getIntermediateCode());
		exp.setVector();
		RESULT = exp;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // expresion ::= expresion AND_LOGICA expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		Expresion exp = new Expresion();
		if ((!(e1.esLogica())) || (!(e2.esLogica())))
		{
			semanticErrorManager.semanticFatalError("Error, operacion and logica entre expresiones aritmeticas.");
		}
		exp.setLogica();
		ScopeIF scope = scopeManager.getCurrentScope();
		
		//GENERACION DE CODIGO INTERMEDIO
		TemporalFactory tf = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		TemporalIF temp1 = e1.getTemporal();
		TemporalIF temp2 = e2.getTemporal();
		TemporalIF temp = tf.create();
		cb.addQuadruples(e1.getIntermediateCode());
		cb.addQuadruples(e2.getIntermediateCode());
		cb.addQuadruple("AND", temp, temp1, temp2);
		exp.setIntermediateCode(cb.create());
		exp.setTemporal(temp);
		//printamos el código intermedio generado
		System.out.println("Codigo intermedio exp and: " + exp.getIntermediateCode());
		RESULT = exp;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // expresion ::= expresion EQUAL expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		Expresion exp = new Expresion();
		if (!((e1.esLogica()&&(e2.esLogica()))||((e1.esAritmetica())&&(e2.esAritmetica()))))
		{
			semanticErrorManager.semanticFatalError("Error al comparar igualdad de expresiones logicas con aritmeticas.");
		}
		exp.setLogica();
		ScopeIF scope = scopeManager.getCurrentScope();
		
		//GENERACION DE CODIGO INTERMEDIO
		TemporalFactory tf = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		TemporalIF temp1 = e1.getTemporal();
		TemporalIF temp2 = e2.getTemporal();
		TemporalIF temp = tf.create();
		cb.addQuadruples(e1.getIntermediateCode());
		cb.addQuadruples(e2.getIntermediateCode());
		cb.addQuadruple("EQ", temp, temp1, temp2);
		exp.setIntermediateCode(cb.create());
		exp.setTemporal(temp);
		//printamos el código intermedio generado
		System.out.println("Codigo intermedio exp igual: " + exp.getIntermediateCode());
		RESULT = exp;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // expresion ::= expresion LOWER_THAN expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
			
		Expresion exp = new Expresion();
		if ((!(e1.esAritmetica())) || (!(e2.esAritmetica())))
		{
			semanticErrorManager.semanticFatalError("Error al comparar expresiones logicas con expresion menor que.");
		}
		exp.setLogica();
		ScopeIF scope = scopeManager.getCurrentScope();
		
		//GENERACION DE CODIGO INTERMEDIO
		TemporalFactory tf = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		TemporalIF temp1 = e1.getTemporal();
		TemporalIF temp2 = e2.getTemporal();
		TemporalIF temp = tf.create();
		cb.addQuadruples(e1.getIntermediateCode());
		cb.addQuadruples(e2.getIntermediateCode());
		cb.addQuadruple("LS", temp, temp1, temp2);
		exp.setIntermediateCode(cb.create());
		exp.setTemporal(temp);
		//printamos el código intermedio generado
		System.out.println("Codigo intermedio exp menor: " + exp.getIntermediateCode());
		RESULT = exp;
		
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // expresion ::= NEGACION expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		Expresion exp = new Expresion();
		if (!(e1.esLogica()))
		{
			semanticErrorManager.semanticFatalError("Error al negar una expresion aritmetica.");
		}
		exp.setLogica();
		ScopeIF scope = scopeManager.getCurrentScope();
		
		
		//GENERACION DE CODIGO INTERMEDIO
		TemporalFactory tf = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		TemporalIF temp1 = e1.getTemporal();
		TemporalIF temp = tf.create();
		cb.addQuadruples(e1.getIntermediateCode());
		cb.addQuadruple("NEG", temp1);
		exp.setIntermediateCode(cb.create());
		exp.setTemporal(temp1);
		//printamos el código intermedio generado
		System.out.println("Codigo intermedio exp neg: " + exp.getIntermediateCode());
		RESULT = exp;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // expresion ::= expresion AUTO_INCREMENTO 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		Expresion exp = new Expresion();
		if (!(e1.esAritmetica()))
		{
			semanticErrorManager.semanticFatalError("Error al incrementar una expresion logica.");
		}
		exp.setAritmetica();
		ScopeIF scope = scopeManager.getCurrentScope();
		
		
		//GENERACION DE CODIGO INTERMEDIO
		TemporalFactory tf = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		TemporalIF temp1 = e1.getTemporal();
		cb.addQuadruples(e1.getIntermediateCode());
		cb.addQuadruple("INC", temp1);
		exp.setIntermediateCode(cb.create());
		exp.setTemporal(temp1);
		//printamos el código intermedio generado
		System.out.println("Codigo intermedio exp aut: " + exp.getIntermediateCode());
		RESULT = exp;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // expresion ::= expresion MULT expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		Expresion exp = new Expresion();
		if ((!(e1.esAritmetica())) || (!(e2.esAritmetica())))
		{
			semanticErrorManager.semanticFatalError("Error al multiplicar expresiones logicas.");
		}
		exp.setAritmetica();
		ScopeIF scope = scopeManager.getCurrentScope();
		
		//GENERACION DE CODIGO INTERMEDIO
		TemporalFactory tf = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		TemporalIF temp1 = e1.getTemporal();
		TemporalIF temp2 = e2.getTemporal();
		TemporalIF temp = tf.create();
		cb.addQuadruples(e1.getIntermediateCode());
		cb.addQuadruples(e2.getIntermediateCode());
		cb.addQuadruple("MUL", temp, temp1, temp2);
		exp.setIntermediateCode(cb.create());
		exp.setTemporal(temp);
		//printamos el código intermedio generado
		System.out.println("Codigo intermedio exp mult: " + exp.getIntermediateCode());
		RESULT = exp;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // expresion ::= expresion PLUS expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		Expresion exp = new Expresion();
		if ((!(e1.esAritmetica())) || (!(e2.esAritmetica())))
		{
			semanticErrorManager.semanticFatalError("Error al sumar expresiones logicas.");
		}
		exp.setAritmetica();
		ScopeIF scope = scopeManager.getCurrentScope();
		
		//GENERACION DE CODIGO INTERMEDIO
		TemporalFactory tf = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		TemporalIF temp1 = e1.getTemporal();
		TemporalIF temp2 = e2.getTemporal();
		TemporalIF temp = tf.create();
		cb.addQuadruples(e1.getIntermediateCode());
		cb.addQuadruples(e2.getIntermediateCode());
		cb.addQuadruple("ADD", temp, temp1, temp2);
		exp.setIntermediateCode(cb.create());
		exp.setTemporal(temp);
		//printamos el código intermedio generado
		System.out.println("Codigo intermedio exp suma: " + exp.getIntermediateCode());
		RESULT = exp;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // expresion ::= OPEN_KEY expresion CLOSE_KEY 
            {
              Expresion RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion expr = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		Expresion exp = new Expresion();
		if (expr.esVector())
		{
			exp.setVector();
		}
		if (expr.esFuncion())
		{
			exp.setFuncion();
		}
		if (expr.esLogica())
		{
			exp.setLogica();
		}
		if (expr.esAritmetica())
		{
			exp.setAritmetica();
		}
		ScopeIF scope = scopeManager.getCurrentScope();
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		TemporalFactory tf = new TemporalFactory(scope);
		TemporalIF temp = expr.getTemporal();
		cb.addQuadruples(expr.getIntermediateCode());
		exp.setTemporal(temp);
		exp.setIntermediateCode(cb.create());
		RESULT = exp;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // expresion ::= IDENTIFICADOR 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		//Comprobamos que el identificador exista en los ámbitos abiertos
		if (!scopeManager.containsSymbol(id.getLexema()))
		{
		semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " no existe en los ambitos abiertos.");
		}
		//Obtenemos símbolo
		SymbolIF sim = scopeManager.searchSymbol(id.getLexema());
		//Comprobamos que sea una constante, variable o parámetro
		if (sim instanceof SymbolFunction)
		{
			semanticErrorManager.semanticFatalError("El símbolo "+ id.getLexema() + " no es ni una constante ni una variable ni un parametro.");
		}
		//Comprobamos que el tipo sea entero
		//Obtenemos su tipo
		TypeIF tipo = sim.getType();
		if (!(tipo.getName().equals("ENTERO")))
		{
			semanticErrorManager.semanticFatalError("El identificador " + id.getLexema() + " no es de tipo entero.");
		}
		Expresion exp = new Expresion();
		//Si es una constante almacenamos su valor
		if (sim instanceof SymbolConstant)
		{
			int valor = ((SymbolConstant)sim).getValor();
			exp.setValor(valor);
			exp.setConstante();
		}


		// GENERACION DE CODIGO INTERMEDIO
		
		ScopeIF scope = scopeManager.getCurrentScope();
		TemporalFactory tf = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		TemporalIF temp = tf.create();
		if (sim instanceof SymbolConstant) 
		{
			Value valor = new Value(((SymbolConstant)sim).getValor());
			cb.addQuadruple("MV", temp, valor);
		} 
		else if ((sim instanceof SymbolVariable) || (sim instanceof SymbolParameter)) 
		{
			Variable var = new Variable(id.getLexema(), sim.getScope());
			cb.addQuadruple("MV", temp, var);
		}
		//añadir el temporal y el código intermedio generado a la expression
		exp.setTemporal(temp);
		exp.setIntermediateCode(cb.create());
		//printamos el código intermedio generado (opcional)
		System.out.println("Codigo intermedio expresion IDENTIFICADOR: " + exp.getIntermediateCode());
		exp.setAritmetica();
		exp.setLogica();
		exp.setIdentificador();
		exp.setLexema(id.getLexema());
		RESULT = exp;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // expresion ::= NUMERO 
            {
              Expresion RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				Expresion exp = new Expresion();

				// GENERACION DE CODIGO INTERMEDIO
				ScopeIF scope = scopeManager.getCurrentScope();
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				Value valor = new Value(Integer.parseInt(num.getLexema()));
				cb.addQuadruple("MV", temp, valor);
				
				//añadir el temporal y el código intermedio generado a la expression
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());
				//printamos el código intermedio generado (opcional)
				System.out.println("Codigo intermedio expresion NUMERO: " + exp.getIntermediateCode());
				exp.setAritmetica();
				exp.setLogica();
				exp.setValor(Integer.parseInt(num.getLexema()));
				exp.setNumero();
				RESULT = exp;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // cuerpoPrincipal ::= seccionTipos seccionVariables listadoSentencias 
            {
              CuerpoPrincipal RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListadoSentencias lista = (ListadoSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				CuerpoPrincipal cuerpo = new CuerpoPrincipal();
				ArrayList<Sentencia> array = lista.devuelveSentencias();
				for (int i=0;i<array.size();i++)
					{
						if (array.get(i).devuelveVacio())
						{
							cuerpo.setVacio();
						}
						if (array.get(i).devuelveResultado())
						{
							cuerpo.setResultado();
						}
						if (array.get(i).devuelveVacioParcial())
						{
							cuerpo.setVacioParcial();
						}
						if (array.get(i).devuelveResultadoParcial())
						{
							cuerpo.setResultadoParcial();
						}
					}
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					cb.addQuadruples(lista.getIntermediateCode());
					cuerpo.setIntermediateCode(cb.create());
				RESULT = cuerpo;						
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpoPrincipal",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // cuerpoPrincipal ::= seccionTipos listadoSentencias 
            {
              CuerpoPrincipal RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListadoSentencias lista = (ListadoSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				CuerpoPrincipal cuerpo = new CuerpoPrincipal();
				ArrayList<Sentencia> array = lista.devuelveSentencias();
				for (int i=0;i<array.size();i++)
					{
						if (array.get(i).devuelveVacio())
						{
							cuerpo.setVacio();
						}
						if (array.get(i).devuelveResultado())
						{
							cuerpo.setResultado();
						}
						if (array.get(i).devuelveVacioParcial())
						{
							cuerpo.setVacioParcial();
						}
						if (array.get(i).devuelveResultadoParcial())
						{
							cuerpo.setResultadoParcial();
						}
					}
					
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					cb.addQuadruples(lista.getIntermediateCode());
					cuerpo.setIntermediateCode(cb.create());
				RESULT = cuerpo;						
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpoPrincipal",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // funcionPrincipal ::= VACIO principal OPEN_KEY CLOSE_KEY OPEN_PARENTHESIS NT$6 cuerpoPrincipal NT$7 CLOSE_PARENTHESIS 
            {
              FuncionPrincipal RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (FuncionPrincipal) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		CuerpoPrincipal cuerpo = (CuerpoPrincipal)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
												//cerramos ambito principal
												scopeManager.closeScope();
												
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionPrincipal",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // NT$7 ::= 
            {
              FuncionPrincipal RESULT =(FuncionPrincipal) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CuerpoPrincipal cuerpo = (CuerpoPrincipal)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

													FuncionPrincipal funprin = new FuncionPrincipal();
													if (cuerpo.devuelveResultado())
														{
															semanticErrorManager.semanticFatalError("La sentencia Devuelve de la funcion principal no puede devolver ningún valor.");
														}
													if (!(cuerpo.devuelveVacio()))
														{
															semanticErrorManager.semanticFatalError("Falta la sentencia Devuelve en la función principal");
														}
													if (cuerpo.devuelveResultadoParcial())
														{
															semanticErrorManager.semanticFatalError("Sentencia Devuelve en la función principal devuelve un valor");
														}
													ScopeIF scope = scopeManager.getCurrentScope();
													IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
													cb.addQuadruples(cuerpo.getIntermediateCode());
													funprin.setIntermediateCode(cb.create());
													RESULT = funprin;
												
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$7",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // NT$6 ::= 
            {
              FuncionPrincipal RESULT =null;


												//creamos en ámbito principal
												String ambito = "principal";
												scopeManager.openScope(ambito);
												
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$6",49, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // parametro ::= IDENTIFICADOR IDENTIFICADOR 
            {
              Parametro RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			semanticErrorManager.semanticFatalError("Error al declarar el parametro " + id.getLexema() + ". Los parametros deben ser de tipo entero.");
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // parametro ::= ENTERO IDENTIFICADOR 
            {
              Parametro RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			Parametro iden = new Parametro();
			String ident = id.getLexema();
			iden.setLexema(ident);
			//Si no hay valor definido inicializamos a 0
			iden.setValor(0);
			iden.setTipo("ENTERO");
			RESULT = iden;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // declaracionParametros ::= parametro 
            {
              DeclaracionParametros RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Parametro id = (Parametro)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							DeclaracionParametros list = new DeclaracionParametros();
							Parametro iden = new Parametro(id.getLexema(),id.getValor(),id.getTipo());
							list.addParametro(iden);
							RESULT = list;
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaracionParametros",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // declaracionParametros ::= declaracionParametros COLON parametro 
            {
              DeclaracionParametros RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		DeclaracionParametros lista = (DeclaracionParametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Parametro id = (Parametro)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							DeclaracionParametros list = new DeclaracionParametros();
							list.actualizarLista(lista.extraerLista());
							Parametro iden = new Parametro(id.getLexema(),id.getValor(),id.getTipo());
							list.addParametro(iden);
							RESULT = list;
							
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaracionParametros",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // seccionParametros ::= epsilon 
            {
              Object RESULT =null;
		
													DeclaracionParametros list = new DeclaracionParametros();
													RESULT = list;
											
              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionParametros",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // seccionParametros ::= declaracionParametros 
            {
              Object RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		DeclaracionParametros lista = (DeclaracionParametros)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
													DeclaracionParametros list = new DeclaracionParametros();
													list.actualizarLista(lista.extraerLista());
													RESULT = list;
											
              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionParametros",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // funcion ::= VACIO IDENTIFICADOR OPEN_KEY seccionParametros CLOSE_KEY OPEN_PARENTHESIS NT$4 cuerpoPrincipal NT$5 CLOSE_PARENTHESIS 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		CuerpoPrincipal cuerpo = (CuerpoPrincipal)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
															//cerramos ambito de la funcion
															scopeManager.closeScope();	
															
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcion",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // NT$5 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CuerpoPrincipal cuerpo = (CuerpoPrincipal)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
															
																if (cuerpo.devuelveResultado())
																{
																	semanticErrorManager.semanticFatalError("La sentencia Devuelve de la funcion " + id.getLexema() + " no debe devolver ningun valor.");
																}
																if (!(cuerpo.devuelveVacio()))
																{
																	semanticErrorManager.semanticFatalError("Falta la sentencia Devuelve en la función " + id.getLexema());
																}
																if (cuerpo.devuelveResultadoParcial())
																{
																	semanticErrorManager.semanticFatalError("Sentencia Devuelve en la función " + id.getLexema() +" devuelve un valor y no deberia");
																}																
															
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",48, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // NT$4 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

															//creamos el ambito de la funcion
															String ambito = id.getLexema();
															scopeManager.openScope(ambito);
															//Obtenemos ambito
															ScopeIF scope = scopeManager.getCurrentScope();
															//Obtenemos tabla de simbolos
															SymbolTableIF tablaSim = scope.getSymbolTable ();
															//Creamos Simbolo funcion
															ScopeIF scopeglob = scope.getParentScope();
															TypeIF tipoVac = scopeManager.searchType("VACIO");
															SymbolFunction func = new SymbolFunction(scopeglob,id.getLexema(),tipoVac);
															
															//Leemos lista de parametros
															ArrayList<Parametro> param =((DeclaracionParametros)lista).extraerLista();
															for (int i=0;i<param.size();i++)
															{
																String nom = param.get(i).getLexema();
																//Comprobamos que el tipo del parametro existe
																
																TypeIF tipo = scopeManager.searchType(param.get(i).getTipo());
																if (tipo == null)
																{
																	semanticErrorManager.semanticFatalError("Tipo " + param.get(i).getTipo() + " del parametro " + param.get(i).getLexema() + " no existe.");
																}
																
																//Comprobamos que el identificador del parámetro no esta en la tabla de simbolos, que no sea un tipo o una constante
																else if (tablaSim.containsSymbol(nom))
																{
																	semanticErrorManager.semanticFatalError("El parametro "+ nom +" ya existe.");
																}
																else if (scopeManager.searchSymbol(nom) instanceof SymbolConstant)
																{
																	semanticErrorManager.semanticFatalError("Identificador " + nom + " ya declarado como constante");
																}
																else if (scopeManager.containsType(nom))
																{
																	semanticErrorManager.semanticFatalError("Identificador " + nom + " ya declarado como tipo");
																}
																else
																{
																//Almacenamos parametro en tabla de simbolos
																	SymbolParameter par = new SymbolParameter(scope,nom,tipo);
																	par.setValor(0);
																	tablaSim.addSymbol(par);
																//Tambien en el objeto SymbolFunction
																	func.addParametro(param.get(i));
																}
																
																
															}
															//Comprobamos que el identificador de la funcion no exista
															SymbolTableIF tablaSimGlob = scopeglob.getSymbolTable ();
															if (tablaSimGlob.containsSymbol(id.getLexema()))
															{
																semanticErrorManager.semanticFatalError("El identificador "+ id.getLexema() + " ya existe.");
															}
															//Almacenamos la funcion en tabla de simbolos de ambito global
															tablaSimGlob.addSymbol(func);
															
															
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",47, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // funcion ::= ENTERO IDENTIFICADOR OPEN_KEY seccionParametros CLOSE_KEY OPEN_PARENTHESIS NT$2 cuerpoPrincipal NT$3 CLOSE_PARENTHESIS 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		CuerpoPrincipal cuerpo = (CuerpoPrincipal)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
															//cerramos ambito de la funcion
															scopeManager.closeScope();
															
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcion",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // NT$3 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CuerpoPrincipal cuerpo = (CuerpoPrincipal)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
															
																if (cuerpo.devuelveVacio())
																{
																	semanticErrorManager.semanticFatalError("La sentencia Devuelve de la funcion " + id.getLexema() + " debe devolver un valor.");
																}
																if (!(cuerpo.devuelveResultado()))
																{
																	semanticErrorManager.semanticFatalError("Falta la sentencia Devuelve en la función " + id.getLexema());
																}
																if (cuerpo.devuelveVacioParcial())
																{
																	semanticErrorManager.semanticFatalError("Sentencia Devuelve en la función " + id.getLexema() +" debe devolver un valor");
																}
																
																
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // NT$2 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

															//creamos el ambito de la funcion
															String ambito = id.getLexema();
															scopeManager.openScope(ambito);
															//Obtenemos ambito
															ScopeIF scope = scopeManager.getCurrentScope();
															//Obtenemos tabla de simbolos
															SymbolTableIF tablaSim = scope.getSymbolTable ();
															//Creamos Simbolo funcion
															ScopeIF scopeglob = scope.getParentScope();
															TypeIF tipoEnt = scopeManager.searchType("ENTERO");
															SymbolFunction func = new SymbolFunction(scopeglob,id.getLexema(),tipoEnt);
															
															//Leemos lista de parametros
															ArrayList<Parametro> param =((DeclaracionParametros)lista).extraerLista();
															for (int i=0;i<param.size();i++)
															{
																String nom = param.get(i).getLexema();
																//Comprobamos que el tipo del parametro existe
																
																TypeIF tipo = scopeManager.searchType(param.get(i).getTipo());
																if (tipo == null)
																{
																	semanticErrorManager.semanticFatalError("Tipo " + param.get(i).getTipo() + " del parametro " + param.get(i).getLexema() + " no existe.");
																}
																
																//Comprobamos que el identificador del parámetro no esta en la tabla de simbolos, que no sea un tipo o una constante
																else if (tablaSim.containsSymbol(nom))
																{
																	semanticErrorManager.semanticFatalError("El parametro "+ nom + " ya existe.");
																}
																else if (scopeManager.searchSymbol(nom) instanceof SymbolConstant)
																{
																	semanticErrorManager.semanticFatalError("Identificador " + nom + " ya declarado como constante");
																}
																else if (scopeManager.containsType(nom))
																{
																	semanticErrorManager.semanticFatalError("Identificador " + nom + " ya declarado como tipo");
																}
																else
																{
																//Almacenamos parametro en tabla de simbolos
																	SymbolParameter par = new SymbolParameter(scope,nom,tipo);
																	par.setValor(0);
																	tablaSim.addSymbol(par);
																//Tambien en el objeto SymbolFunction
																	func.addParametro(param.get(i));
																}
																
																
															}
															//Comprobamos que el identificador de la funcion no exista
															SymbolTableIF tablaSimGlob = scopeglob.getSymbolTable ();
															if (tablaSimGlob.containsSymbol(id.getLexema()))
															{
																semanticErrorManager.semanticFatalError("El identificador "+ id.getLexema() + " ya existe.");
															}
															//Almacenamos la funcion en tabla de simbolos de ambito global
															tablaSimGlob.addSymbol(func);
															
															
															
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",45, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // seccionFunciones ::= funcionPrincipal 
            {
              SeccionFunciones RESULT =null;
		int funleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int funright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		FuncionPrincipal fun = (FuncionPrincipal)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			SeccionFunciones secfun = new SeccionFunciones();
			ScopeIF scope = scopeManager.getCurrentScope();
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			cb.addQuadruples(fun.getIntermediateCode());
			secfun.setIntermediateCode(cb.create());
			RESULT = secfun;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionFunciones",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // seccionFunciones ::= funcion seccionFunciones 
            {
              SeccionFunciones RESULT =null;
		int secleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int secright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SeccionFunciones sec = (SeccionFunciones)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			SeccionFunciones secfun = new SeccionFunciones();
			ScopeIF scope = scopeManager.getCurrentScope();
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			cb.addQuadruples(sec.getIntermediateCode());
			secfun.setIntermediateCode(cb.create());
			RESULT = secfun;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionFunciones",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // id ::= IDENTIFICADOR ASSIGN NUMERO 
            {
              Id RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			Id iden = new Id();
			String ident = id.getLexema();
			int val = Integer.parseInt(num.getLexema());
			iden.setValor(val);
			iden.setLexema(ident);
			RESULT = iden;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("id",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // id ::= IDENTIFICADOR 
            {
              Id RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			Id iden = new Id();
			String ident = id.getLexema();
			iden.setLexema(ident);
			//Si no hay valor definido inicializamos a 0
			iden.setValor(0);
			RESULT = iden;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("id",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // listadoIDs ::= id 
            {
              ListadoIds RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Id id = (Id)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			ListadoIds list = new ListadoIds();
			Id iden = new Id(id.getLexema(),id.getValor());
			list.addId(iden);
			RESULT = list;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("listadoIDs",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // listadoIDs ::= listadoIDs COLON id 
            {
              ListadoIds RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ListadoIds lista = (ListadoIds)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Id id = (Id)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			ListadoIds list = new ListadoIds();
			list.actualizarLista(lista.extraerLista());
			Id iden = new Id(id.getLexema(),id.getValor());
			list.addId(iden);
			RESULT = list;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("listadoIDs",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // declaracionVariable ::= IDENTIFICADOR listadoIDs SEMI_COLON 
            {
              Object RESULT =null;
		int tipleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tipright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token tip = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListadoIds lista = (ListadoIds)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			//Obtenemos ambito
			ScopeIF scope = scopeManager.getCurrentScope();
			//Obtenemos tabla de simbolos
			SymbolTableIF tablaSim = scope.getSymbolTable ();
			
			//Comprobamos que el tipo de las variables existe
			TypeIF tipo = scopeManager.searchType(tip.getLexema());
			if (tipo == null)
				{
				semanticErrorManager.semanticFatalError("Tipo " + tip.getLexema() + " no existe.");
				}
			
			//Recorremos lista de identificadores comprobando si existen en la tabla de simbolos, son tipos o constantes
			ArrayList<Id> identificadores = lista.extraerLista();
			for (int i=0;i<identificadores.size();i++)
				{
				String nom = identificadores.get(i).getLexema();
				if (tablaSim.containsSymbol(nom))
					{
					semanticErrorManager.semanticFatalError("Identificador de variable "+ nom +" ya definido.");
					}
				else if (scopeManager.searchSymbol(nom) instanceof SymbolConstant)
					{
					semanticErrorManager.semanticFatalError("Identificador " + nom + " ya declarado como constante");
					}
				else if (scopeManager.containsType(nom))
					{
					semanticErrorManager.semanticFatalError("Identificador " + nom + " ya declarado como tipo");
					}
				else
					{
					//Almacenamos variable en tabla de simbolos
					SymbolVariable var = new SymbolVariable(scope,nom,tipo);
					int val = identificadores.get(i).getValor();
					var.setValor(val);
					tablaSim.addSymbol(var);
					}
				}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaracionVariable",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // declaracionVariable ::= ENTERO listadoIDs SEMI_COLON 
            {
              Object RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListadoIds lista = (ListadoIds)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			//Obtenemos ambito
			ScopeIF scope = scopeManager.getCurrentScope();
			//Obtenemos tabla de simbolos
			SymbolTableIF tablaSim = scope.getSymbolTable ();
			
			//Recorremos lista de identificadores comprobando si existen en la tabla de simbolos, son tipos o constantes
			ArrayList<Id> identificadores = lista.extraerLista();
			for (int i=0;i<identificadores.size();i++)
				{
				String nom = identificadores.get(i).getLexema();
				if (tablaSim.containsSymbol(nom))
					{
					semanticErrorManager.semanticFatalError("Identificador de variable "+ nom +" ya definido.");
					}
				else if (scopeManager.searchSymbol(nom) instanceof SymbolConstant)
					{
					semanticErrorManager.semanticFatalError("Identificador " + nom + " ya declarado como constante");
					}
				else if (scopeManager.containsType(nom))
					{
					semanticErrorManager.semanticFatalError("Identificador " + nom + " ya declarado como tipo");
					}
				else
					{
					//Almacenamos variable en tabla de simbolos
					TypeIF tipo = scopeManager.searchType("ENTERO");
					SymbolVariable var = new SymbolVariable(scope,nom,tipo);
					int val = identificadores.get(i).getValor();
					var.setValor(val);
					tablaSim.addSymbol(var);
					}
				}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaracionVariable",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // seccionVariables ::= declaracionVariable 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionVariables",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // seccionVariables ::= seccionVariables declaracionVariable 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionVariables",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // tamTipo ::= IDENTIFICADOR 
            {
              TamTipo RESULT =null;
		int tamleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tamright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token tam = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		TamTipo identificador = new TamTipo();
		String ident = tam.getLexema();
		identificador.setValor(ident);
		identificador.marcaIdentificador();
		RESULT = identificador;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tamTipo",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // tamTipo ::= NUMERO 
            {
              TamTipo RESULT =null;
		int tamleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tamright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token tam = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		TamTipo numero = new TamTipo();
		String num = tam.getLexema();
		numero.setValor(num);
		RESULT = numero;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tamTipo",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // declaracionTipo ::= TIPO ENTERO IDENTIFICADOR OPEN_BRACKET tamTipo CLOSE_BRACKET SEMI_COLON 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tamleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tamright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		TamTipo tam = (TamTipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		//Obtenemos ambito
		ScopeIF scope = scopeManager.getCurrentScope();
		//Obtenemos tabla de tipos
		TypeTableIF tablaTipos = scope.getTypeTable ();

		//Comprobamos si el tipo existe 
		String nom = id.getLexema();
		if (scopeManager.containsType(nom))
		{
			semanticErrorManager.semanticFatalError("Tipo " + nom + " ya declarado");
		}
		else if (scopeManager.searchSymbol(nom) instanceof SymbolConstant)
		{
			semanticErrorManager.semanticFatalError("Identificador " + nom + " ya declarado como constante");
		}
		else
		{
			//Si no existe comprobamos si el tamaño es un numero o un identificador
			int tamano;
			if (tam.esIdentificador())
			{
				//Si es una constante comprobamos que está declarada en el ámbito global
				if (scopeManager.containsSymbol(tam.getValor())) 
				{
					ScopeIF global = scopeManager.getScope(0);
					SymbolTableIF tablaSimbolosGlobal = global.getSymbolTable();
					SymbolIF Simbolo = tablaSimbolosGlobal.getSymbol(tam.getValor());
					int valor = ((SymbolConstant) Simbolo).getValor();
					if (valor == 0) {semanticErrorManager.semanticFatalError("El tamaño de " + nom + " debe ser mayor que 0");}
					TypeArray tArray = new TypeArray(scope,nom,valor);
					tablaTipos.addType(nom,tArray);
				} 
			else
			{
			//Si no está declarada mostramos un error
			semanticErrorManager.semanticFatalError("No existe la constante " + tam.getValor());
				}
				}else
			{		
		//Si no es una constante almacenamos su valor si es mayor de 0
			tamano = Integer.parseInt(tam.getValor());
			if (tamano>0)
			{
				TypeArray tArray = new TypeArray(scope,nom,tamano);
				tablaTipos.addType(nom,tArray);
			}else{
			semanticErrorManager.semanticFatalError("El tamaño de " + nom + " debe ser mayor que 0");
			}
			}	
		}			
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaracionTipo",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // seccionTipos ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionTipos",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // seccionTipos ::= declaracionTipo seccionTipos 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionTipos",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // declaracionConstante ::= CONSTANTE IDENTIFICADOR NUMERO SEMI_COLON 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		//recuperamos el ámbito donde nos encontramos y obtenemos la tabla de símbolos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos =scope.getSymbolTable();
		String nombre = id.getLexema();

		//comprobamos que la constante no este ya declarada en la tabla de símbolos
		if (tablaSimbolos.containsSymbol(nombre)) 
		{
			semanticErrorManager.semanticFatalError("Constante " + nombre + " ya declarada");
		} 
		else 
		{
			//introducimos en la tabla de símbolos la constante con su ámbito, nombre, tipo y su valor
			TypeTableIF tablaTipos = scope.getTypeTable();
			TypeIF tipo = scopeManager.searchType("ENTERO");
			SymbolConstant simboloConstante = new SymbolConstant(scope, nombre, tipo);
			simboloConstante.setValor(Integer.parseInt(valor.getLexema()));
			tablaSimbolos.addSymbol(simboloConstante);
		}
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaracionConstante",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // epsilon ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("epsilon",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // seccionConstantes ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionConstantes",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // seccionConstantes ::= declaracionConstante seccionConstantes 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionConstantes",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // axiomAux ::= seccionConstantes seccionTipos seccionFunciones 
            {
              AxiomAux RESULT =null;
		int secleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int secright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SeccionFunciones sec = (SeccionFunciones)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			AxiomAux axi = new AxiomAux();
			ScopeIF scope = scopeManager.getCurrentScope();
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			cb.addQuadruples(sec.getIntermediateCode());
			axi.setIntermediateCode(cb.create());
			RESULT = axi;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiomAux",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // axiomAux ::= seccionConstantes seccionTipos seccionVariables seccionFunciones 
            {
              AxiomAux RESULT =null;
		int secleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int secright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SeccionFunciones sec = (SeccionFunciones)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			AxiomAux axi = new AxiomAux();
			ScopeIF scope = scopeManager.getCurrentScope();
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			cb.addQuadruples(sec.getIntermediateCode());
			axi.setIntermediateCode(cb.create());
			RESULT = axi;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiomAux",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= NT$1 axiomAux 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AxiomAux ax = (AxiomAux)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
		AxiomAux axi = new AxiomAux();
		ScopeIF scope = scopeManager.getCurrentScope();
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		cb.addQuadruples(ax.getIntermediateCode());
		//Añadimos cuadrupla halt
		cb.addQuadruple("HALT");
		//Comprobamos que estamos en el ámbito del programa principal ámbito de nivel 0 y
		//añadimos las listas de cadenas al final del código intermedio generado
		if (scope.getLevel() == 0) 
		{
			for (int i=0; i< listaCadenas.size(); i++) 
			{
				cb.addQuadruple(listaCadenas.get(i));
			}
		}
		axi.setIntermediateCode(cb.create());
		RESULT = axi;	
		//Cerramos ambito global
		scopeManager.closeScope();
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Axiom RESULT =null;

		//creamos en ámbito global
		String ambito = "global";
		scopeManager.openScope(ambito);
		ScopeIF scope = scopeManager.getCurrentScope();
		
		//Obtenemos del ámbito creado la Tabla del Tipos
		TypeTableIF tablaTipos = scope.getTypeTable ();

		//Introducción en la Tabla de Tipos del Tipo Simple Entero
		TypeSimple tsEntero = new TypeSimple(scope, "ENTERO");
		tablaTipos.addType("ENTERO",tsEntero);

		// Introducción en la Tabla de Tipos del Tipo Simple Vacío
		TypeSimple tsVacio = new TypeSimple(scope, "VACIO");
		tablaTipos.addType("VACIO",tsVacio);
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		   		
		//Asignación de posiciones de memoria para las variables globales y los temporales
		List<ScopeIF> scopes = scopeManager.getAllScopes();
		int direccionEstatica = 65535;
		for (ScopeIF scope: scopes) 
		{
			List<SymbolIF> simbolos = scope.getSymbolTable().getSymbols();
			for (SymbolIF simbolo: simbolos) 
			{
				if (simbolo instanceof SymbolVariable) 
					{ 
						//Guardamos la dirección del variable en SymbolVariable	
						((SymbolVariable)simbolo).setAddress(direccionEstatica);
						//Actualizamos el valor de direccionEstatica para el próximo símbolo
						direccionEstatica = direccionEstatica - simbolo.getType().getSize();
					}
			}
			//al igual que se hicimos con las variables lo hacemos con los temporales
			List<TemporalIF> temporales = scope.getTemporalTable().getTemporals();
			for (TemporalIF t: temporales) 
			{
				if (t instanceof Temporal) 
					{
						//Guardamos la dirección del temporal en Temporal.java
						((Temporal)t).setAddress(direccionEstatica);
						direccionEstatica = direccionEstatica - ((Temporal)t).getSize();
					}
			}
		}
		//Generación de código intermedio para iniciar el programa principal e inicializar las variables globales
		for (ScopeIF scope: scopes) 
		{
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			if (scope.getLevel () == 0) 
			{
				List<SymbolIF> simbolos = scope.getSymbolTable ().getSymbols();
				for (SymbolIF simbolo: simbolos) 
					{
						if (simbolo instanceof SymbolVariable) 
							{
								ScopeIF scope1 = ((SymbolVariable)simbolo).getScope();
								Variable var = new Variable(simbolo.getName(), scope1);
								// Se inicializa las variables del programa principal a 0
								cb.addQuadruple("VARGLOBAL", var, 0);
							}
					}
			}
			cb.addQuadruples(ax.getIntermediateCode());
			ax.setIntermediateCode(cb.create());
		}
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		//printamos el código intermedio generado
		System.out.println("Codigo intermedio Axioma: " + ax.getIntermediateCode());
  		List intermediateCode = ax.getIntermediateCode ();
		finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores se puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  		
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

